<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>캐릭터 장비 관리</title>
    <style>
        /* ========================================
   1. 기본 스타일 (Body, 헤딩)
   ======================================== */
        body {
            font-family: sans-serif;
            background: #0f1222;
            color: #e6e9ff;
        }

        h1 {
            margin-bottom: 10px;
        }

        h2 {
            margin: 24px 0 8px;
        }

        /* ========================================
           2. 공통 버튼 스타일
           ======================================== */
        .action-btn, .file-label {
            min-width: 140px;
            text-align: center;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
        }

        .action-btn {
            background: linear-gradient(135deg, #25c2a0, #1a8c7d);
            border: none;
            color: #fff;
        }

        .action-btn:hover {
            background: linear-gradient(135deg, #1a8c7d, #25c2a0);
        }

        .file-label {
            background: #4a3f7a;
            color: #fff;
            border: none;
        }

        .file-label:hover {
            background: #5a4f8a;
        }

        .file-label input {
            display: none;
        }

        .add-btn {
            background: linear-gradient(135deg, #ffd700, #e6b800);
            border: none;
            color: #000;
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
        }

        .add-btn:hover {
            background: linear-gradient(135deg, #e6b800, #ffd700);
        }

        /* ========================================
           3. 툴바 영역
           ======================================== */
        .toolbar {
            margin: 15px 0;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        /* ========================================
           4. 폼 (입력창)
           ======================================== */
        .form-box {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        .form-box input {
            width: 20ch;
            padding: 6px;
            border-radius: 6px;
            border: 1px solid #2a3158;
            background: #181c33;
            color: #e6e9ff;
        }

        /* ========================================
           5. 캐릭터 관련 스타일
           ======================================== */
        /* 5-1. 캐릭터 래퍼 (드래그 앤 드롭) */
        .character-wrapper {
            display: inline-flex;
            align-items: center;
            margin: 5px;
            cursor: move;
            transition: all 0.2s ease;
        }

        .character-wrapper.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .character-wrapper.drag-over {
            border-left: 3px solid #ffd700;
            padding-left: 5px;
        }

        /* 5-2. 드래그 핸들 */
        .drag-handle {
            cursor: grab;
            padding: 4px 8px;
            color: #888;
            font-size: 18px;
            user-select: none;
        }

        .drag-handle:hover {
            color: #ffd700;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        /* 5-3. 캐릭터 버튼 */
        .char-btn {
            margin: 5px;
            padding: 10px 16px;
            background: #2a3158;
            border: none;
            border-radius: 6px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
        }

        .char-btn:hover {
            background: #3a4270;
        }

        .char-btn.active {
            border-color: #ffd700 !important;
            color: #ffd700 !important;
            background: rgba(255, 215, 0, 0.1) !important;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
            font-weight: bold;
        }

        /* 5-4. 설정 버튼 */
        .settings-btn {
            background: #4a3f7a;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 5px;
            transition: background 0.2s;
        }

        .settings-btn:hover {
            background: #6254a8;
        }

        /* 5-5. 삭제 버튼 */
        .delete-btn {
            padding: 4px 8px;
            background: linear-gradient(135deg, #8c1a1a, #b22222);
            border: none;
            border-radius: 4px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
        }

        .delete-btn:hover {
            background: linear-gradient(135deg, #b22222, #8c1a1a);
            transform: scale(1.05);
        }

        /* ========================================
           6. 세트 버튼 (장비 세트)
           ======================================== */
        .set-btn {
            margin: 5px;
            padding: 8px 14px;
            min-width: 180px;
            background: #181c33;
            border: 3px solid transparent;
            border-radius: 6px;
            color: #e6e9ff;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
            text-align: center;
            white-space: nowrap;
        }

        .set-btn:hover {
            background: #2a3158;
            border-color: #3a4270;
        }

        .set-btn.selected {
            border: 3px solid #ffffff;
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.7);
        }

        .set-btn.set3 {
            background-color: #25c2a0;
            color: #fff;
        }

        .set-btn.set5 {
            background-color: #ffd700;
            color: #000;
        }

        /* 세트 버튼 내 숫자 색상 */
        .set-btn .count-3 {
            color: #000000;
            font-weight: bold;
        }

        .set-btn .count-5 {
            color: #ff4d4f;
            font-weight: bold;
        }

        /* ========================================
           7. 테이블 (장비 목록)
           ======================================== */
        table {
            border-collapse: collapse;
            margin-top: 6px;
            table-layout: fixed;
        }

        th, td {
            border: 1px solid #2a3158;
            padding: 6px;
            text-align: center;
            white-space: nowrap;
        }

        th {
            background: #181c33;
        }

        tr.set3 {
            background-color: rgba(37, 194, 160, 0.35);
        }

        tr.set5 {
            background-color: rgba(255, 215, 0, 0.45);
        }

        /* ========================================
           8. 숫자 버튼 (장비 개수)
           ======================================== */
        .num-btn {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #2a3158;
            background: #181c33;
            color: #e6e9ff;
            cursor: pointer;
        }

        .num-btn.positive {
            background: linear-gradient(135deg, #3399cc, #2a6f9e);
            color: #fff;
            font-weight: bold;
            border: 1px solid #3399cc;
        }

        /* ========================================
           9. 태그 색상 (익시드, 접두어)
           ======================================== */
        .exceed-tag {
            color: #25c2a0;
            font-weight: bold;
        }

        .prefix-tag {
            color: #e6b800;
            font-weight: bold;
        }

        /* ========================================
           10. 모달 (팝업창)
           ======================================== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: #181c33;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            text-align: center;
            min-width: 300px;
        }

        .modal-content h3 {
            margin-top: 0;
            color: #ffd700;
        }

        .modal-options {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        /* 모달 버튼 공통 */
        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
        }

        /* 모달 버튼 종류별 */
        .modal-delete-btn {
            background: #b22222;
            color: #fff;
        }

        .modal-delete-btn:hover {
            background: #8c1a1a;
        }

        .modal-reset-btn {
            background: #3399cc;
            color: #fff;
        }

        .modal-reset-btn:hover {
            background: #2a6f9e;
        }

        .modal-cancel-btn {
            background: #4a3f7a;
            color: #fff;
        }

        .modal-cancel-btn:hover {
            background: #5a4f8a;
        }

        .modal-edit-btn {
            background: #25c2a0 !important;
            color: white;
        }

        /* ========================================
           11. 페이지네이션
           ======================================== */
        .pagination {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin: 25px 0;
            flex-wrap: wrap;
        }

        .pagination button {
            padding: 10px 15px;
            border: 1px solid #2a3158;
            background: #181c33;
            color: #e6e9ff;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
            min-width: 40px;
        }

        .pagination button:hover {
            background: #2a3158;
            border-color: #3a4270;
        }

        .pagination button.active {
            background: #4a33cc;
            border-color: #ffd700;
            color: #ffd700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
            font-weight: bold;
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* ========================================
           12. 제작 시스템
           ======================================== */
        .craft-input {
            background: #1b1e33;
            color: #e0e0e0;
            border: 1px solid #444a7a;
            border-radius: 4px;
            padding: 4px;
        }

        .craft-input:focus {
            outline: none;
            border-color: #6b5cff;
            background: #20244a;
        }

        /* 숫자 입력 증감 버튼 제거 */
        .craft-input::-webkit-inner-spin-button,
        .craft-input::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .craft-lock-btn {
            background: #2a3158;
            color: #fff;
            border: 2px solid transparent;
            padding: 4px 10px;
            cursor: pointer;
            border-radius: 6px;
        }

        .craft-lock-btn.active {
            border: 2px solid #ffffff;
        }
    </style>
</head>
<body>

<h1>캐릭터 장비 관리</h1>

<div class="toolbar" style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap; padding: 10px 0;">
    <button class="action-btn" style="background: linear-gradient(135deg, #6a5acd, #483d8b);" onclick="exportJSON()">
        💎 JSON 저장 (백업)
    </button>
    <button onclick="saveJsonWithLocation()" class="char-btn" style="background: #e67e22;">📂 JSON 경로 지정 저장</button>
    <label class="file-label" style="background: #2c3e50; margin: 0; cursor: pointer;">
        📥 JSON 불러오기
        <input type="file" id="jsonFile" accept=".json" onchange="importJSON(event)" style="display:none;">
    </label>

    <div style="width: 1px; height: 25px; background: #444; margin: 0 5px;"></div>

    <button id="tab-char" class="modal-btn"
            style="background: #4a33cc; color: #ffffff; border: 1px solid #fff; font-weight: bold;"
            onclick="switchTo('char')">캐릭터 관리
    </button>
    <button id="tab-weapon" class="modal-btn"
            style="background: #2a3158; color: #ffffff; border: 1px solid transparent;" onclick="switchTo('weapon')">무기
        관리
    </button>
    <button id="tab-equipment" class="modal-btn"
            style="background: #2a3158; color: #ffffff; border: 1px solid transparent;" onclick="switchTo('equipment')">
        장비 관리
    </button>
    <button id="tab-craft" class="modal-btn"
            style="background: #2a3158; color: #ffffff; border: 1px solid transparent;"
            onclick="switchTo('craft')">
        제작
    </button>

</div>

<button class="action-btn" onclick="showRecentUpdates()">🌟 최근 업데이트</button>

<div id="section-equipment-view" style="display:none; padding: 20px;">
    <div class="toolbar"
         style="margin-bottom: 20px; display: flex; flex-direction: column; gap: 10px; align-items: flex-start;">

        <div class="equipment-button-row"
             style="display: flex; flex-direction: row; flex-wrap: nowrap; gap: 8px; overflow-x: auto; width: 100%;">
            <button class="char-btn active" style="white-space: nowrap; min-width: 100px;"
                    onclick="renderEquipmentTab('ALL'); setActiveEquipmentButton(this)">모두
            </button>
            <button class="char-btn" style="white-space: nowrap; min-width: 100px;"
                    onclick="renderEquipmentTab('NORMAL'); setActiveEquipmentButton(this)">일반
            </button>
            <button class="char-btn" style="white-space: nowrap; min-width: 100px;"
                    onclick="renderEquipmentTab('PREFIX'); setActiveEquipmentButton(this)">접두어
            </button>
            <button class="char-btn" style="white-space: nowrap; min-width: 100px;"
                    onclick="renderEquipmentTab('EXCEED'); setActiveEquipmentButton(this)">익시드
            </button>
        </div>

        <div class="equipment-button-row"
             style="display: flex; flex-direction: row; flex-wrap: nowrap; gap: 8px; overflow-x: auto; width: 100%;">
            <button class="char-btn" style="white-space: nowrap; min-width: 100px; border-color: #ffd700;"
                    onclick="renderFullEquipmentTab('NORMAL'); setActiveEquipmentButton(this)">일반장비
            </button>
            <button class="char-btn" style="white-space: nowrap; min-width: 100px; border-color: #ffd700;"
                    onclick="renderFullEquipmentTab('PREFIX'); setActiveEquipmentButton(this)">접두어장비
            </button>
            <button class="char-btn" style="white-space: nowrap; min-width: 100px; border-color: #ffd700;"
                    onclick="renderFullEquipmentTab('EXCEED'); setActiveEquipmentButton(this)">익시드장비
            </button>
        </div>

        <!-- ✅ 세 번째 줄도 equipment-button-row 클래스 추가 -->
        <div class="equipment-button-row"
             style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
            <button class="char-btn" style="white-space: nowrap; min-width: 180px; border-color: #ffd700;"
                    onclick="toggleCharacterEquipmentView(); setActiveEquipmentButton(this)">📋 캐릭터별 장비 보유 현황
            </button>
            <button class="char-btn" style="white-space: nowrap; min-width: 100px; border-color: #ffd700;"
                    onclick="showEquipmentStatistics(); setActiveEquipmentButton(this)">📊 통계
            </button>

            <!-- ✅ 검색 기능 추가 -->
            <div style="display: flex; gap: 5px; align-items: center;">
                <input type="text" id="equipment-search-input" placeholder="세트명 검색 (예: 말괄량이)"
                       style="padding: 8px 12px; border-radius: 6px; border: 1px solid #2a3158; background: #181c33; color: #e6e9ff; width: 200px;">
                <button class="char-btn" style="white-space: nowrap; min-width: 80px; background: #25c2a0;"
                        onclick="searchEquipment(); setActiveEquipmentButton(this)">🔍 검색
                </button>
            </div>
        </div>
    </div>

    <div id="equipment-display-area"
         style="overflow-x: auto; background: #0f1222; padding: 15px; border-radius: 8px; border: 1px solid #2a3158;">
    </div>

    <!-- ✅ 새로 추가: 캐릭터 선택 영역 -->
    <div id="character-selection-area" style="display: none; margin-top: 20px;">
        <h3 style="color: #ffd700;">캐릭터 선택</h3>
        <div id="character-buttons-area" style="display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px;">
        </div>
    </div>

    <!-- ✅ 새로 추가: 캐릭터 장비 현황 표시 영역 -->
    <div id="character-equipment-detail" style="display: none; margin-top: 20px;">
    </div>
</div>


<div id="updateModal" class="modal-overlay">
    <div class="modal-content" style="width: 1200px; max-width: 90vw; max-height: 85vh; overflow-y: auto;">
        <h3>🌟 최근 장비 업데이트</h3>

        <div id="updateModalContent"></div>

        <div id="updatePagination" class="pagination"></div>

        <div class="modal-options" style="margin-top: 30px;">
            <button class="modal-btn modal-cancel-btn" onclick="closeUpdateModal()">닫기</button>
        </div>
    </div>
</div>


<div id="section-character-view">
    <h2>[캐릭터]</h2>
    <div class="form-box">
        <input type="text" id="newCharName" placeholder="이름 입력">
        <input type="text" id="newCharJob" placeholder="직업 입력">
        <button class="add-btn" onclick="addCharacter()">➕ 추가</button>
        <!-- ✅ 새로 추가 -->
        <button id="edit-order-btn" class="add-btn" style="background: linear-gradient(135deg, #3399cc, #2a6f9e);"
                onclick="toggleEditMode()">✏️편집</button>
    </div>

    <!-- 💡 순서 초기화 버튼 추가 -->
    <div style="margin-bottom: 10px;">
        <button class="char-btn" style="background: #e67e22; font-size: 0.9em; font-weight: bold;"
                onclick="saveCurrentOrder()">
            💾 순서 등록
        </button>
        <button class="char-btn" style="background: #25c2a0; font-size: 0.9em;"
                onclick="resetToOriginalOrder()">
            🔄 등록 순서로 복원
        </button>
        <button class="char-btn" style="background: #666; font-size: 0.9em;"
                onclick="sortCharactersByName()">
            🔤 이름순 정렬
        </button>
        <button class="char-btn" style="background: #666; font-size: 0.9em;"
                onclick="sortCharactersByJob()">
            💼 직업순 정렬
        </button>
    </div>

    <div id="characterList" class="char-grid"></div>
    <div id="characterDetail" class="detail-container" style="display:none;"></div>

    <div id="setList"></div>
    <div id="panel"></div>
</div>

<div id="section-weapon-view" style="display: none; padding-top: 0;">
    <h2>[무기]</h2>
    <div class="toolbar" id="weaponJobButtons">
        <button class="char-btn" onclick="selectWeaponJob('귀검사')">귀검사</button>
        <button class="char-btn" onclick="selectWeaponJob('격투가')">격투가</button>
        <button class="char-btn" onclick="selectWeaponJob('거너')">거너</button>
        <button class="char-btn" onclick="selectWeaponJob('마법사')">마법사</button>
        <button class="char-btn" onclick="selectWeaponJob('프리스트')">프리스트</button>
        <button class="char-btn" onclick="selectWeaponJob('워리어')">워리어</button>
        <button class="char-btn" onclick="selectWeaponJob('마창사')">마창사</button>
        <button class="char-btn" onclick="selectWeaponJob('도적')">도적</button>
    </div>
    <div id="weaponPanel"></div>
</div>

<div id="section-craft-view" style="display:none; padding:20px;">
    <div style="display:flex; align-items:center; gap:10px;">
        <h2 style="margin:0;">[제작]</h2>

        <button id="craft-lock-btn"
                onclick="setCraftLock(true)"
                class="craft-lock-btn active">
            잠금
        </button>

        <button id="craft-unlock-btn"
                onclick="setCraftLock(false)"
                class="craft-lock-btn">
            해제
        </button>
    </div>
    <div id="craft-table-area"
         style="overflow-x:auto; background:#0f1222; padding:15px;
                border-radius:8px; border:1px solid #2a3158;">
    </div>
</div>


<script>
    /* ═══════════════════════════════════════════════════════════════
       📚 DNF Mobile 장비 관리 시스템
       ═══════════════════════════════════════════════════════════════

       📖 목차 (Ctrl+F로 검색하세요)

       [섹션 1] 전역 변수 & 상수 (670-800줄)
       [섹션 2] 데이터 정의 (800-1200줄)
          ├─ 방어구/악세/특장 세트
          ├─ 표시용 이름 매핑
          └─ 무기 데이터

       [섹션 3] 초기 캐릭터 데이터 (1200-1250줄)

       [섹션 4] 데이터 관리 (1250-1350줄)
          ├─ saveLocalData()
          └─ loadLocalData()

       [섹션 5] 초기 계산 함수 (1350-1380줄)
          └─ calculateGlobalWidths()

       [섹션 6] 유틸리티 함수 (1380-1500줄)
          ├─ calcNameWidth()
          ├─ createEquipmentRow()
          ├─ getExceedColor()
          ├─ formatEquipmentName()
          ├─ isExceedName()
          ├─ getGroupKey()
          ├─ getSetType()
          ├─ calcTotalDistinctParts()
          └─ 캐싱 관련 함수

       [섹션 7] 캐릭터 관리 (1500-1800줄)
          ├─ addCharacter()
          ├─ deleteCharacter()
          ├─ resetCharacterStats()
          ├─ updateCharacterInfo()
          ├─ renderCharacterList()
          ├─ 순서 관리 함수들
          └─ 드래그앤드롭

       [섹션 8] 모달 관리 (1800-1900줄)
          ├─ openActionModal()
          ├─ closeActionModal()
          └─ openConfirmModal()

       [섹션 9] 장비 관리 (1900-3100줄)
          ├─ showSetButtons()
          ├─ makeSetButton()
          ├─ openSet()
          ├─ makeRow()
          ├─ makeNumberButton()
          ├─ increment() / decrement()
          ├─ 업데이트 함수들
          └─ renderEquipmentTab()

       [섹션 10] 무기 관리 (3100-3700줄)
          ├─ selectWeaponJob()
          ├─ makeWeaponNumberButton()
          ├─ incrementWeapon() / decrementWeapon()
          ├─ updateWeaponButton()
          └─ 테이블 강조 함수들

       [섹션 11] 최근 업데이트 (3700-3900줄)
          ├─ showRecentUpdates()
          ├─ renderUpdatePage()
          └─ 페이지네이션

       [섹션 12] 제작 시스템 (3900-4200줄)
          ├─ renderCraftTable()
          └─ setCraftLock()

       [섹션 13] 탭 전환 (4200-4300줄)
          └─ switchTo()

       [섹션 14] JSON 백업/복원 (4300-4500줄)
          ├─ exportJSON()
          ├─ saveJsonWithLocation()
          └─ importJSON()

       [섹션 15] 초기화 (4500-4804줄)
          ├─ 전역 함수 호출
          └─ 이벤트 리스너

       ═══════════════════════════════════════════════════════════════ */

    /* ========================================
       [섹션 1] 전역 변수 & 상수 선언
       ======================================== */
    let activeCharacterId = null;
    let activeWeaponJob = null;
    let currentUpdatePage = 1;
    let allUpdatesData = [];
    const ITEMS_PER_PAGE = 10;
    const TOTAL_PAGES = 5;

    let currentActionCharId = null;

    // ===== 전역 상태 변수 =====
    let currentSetName = null;
    let currentChar = null;
    let currentFilter = 'ALL'; // 💡 현재 선택된 필터 ('ALL', 'BASE', 'PREFIX', 'EXCEED')

    // 💡 무기 테이블 행 강조 함수
    let highlightedRowId = null;

    // 💡 강조 상태를 관리하기 위한 전역 변수 (기존 Set에서 단일 변수로 변경)
    let highlightedColumnIndex = null;

    let craftLocked = true;

    // calcTotalDistinctParts 결과 캐시
    // 구조: { "charId|setName": distinctParts }
    let distinctPartsCache = {};

    // ✅ 추가: 캐릭터 순서 편집 모드
    let isEditingCharacterOrder = false;

    /* ========================================
       [섹션 2] 데이터 정의
       ======================================== */

    // ─────────────────────────────────────────
    // 2.1 방어구 세트
    // ─────────────────────────────────────────
    const ARMOR_SETS = {
        "어느 말괄량이의 탐사복": ["상의", "하의", "어깨", "벨트", "신발"],
        "포이즈닝 퀸 스파이더": ["상의", "하의", "어깨", "벨트", "신발"],
        "거인의 스펙쿨룸 아이언": ["상의", "하의", "어깨", "벨트", "신발"],
        "어둠을 쏘아 내리는 자": ["상의", "하의", "어깨", "벨트", "신발"],
        "수호자의 초합금": ["상의", "하의", "어깨", "벨트", "신발"],
        "스틱키 애시드 웨펀": ["상의", "하의", "어깨", "벨트", "신발"],
        "섬뜩한 강철 용": ["상의", "하의", "어깨", "벨트", "신발"],
        "익스플로시브 버닝 스톤": ["상의", "하의", "어깨", "벨트", "신발"],
        "빛의 헌신자": ["상의", "하의", "어깨", "벨트", "신발"],
        "여명을 쏘아 올리는 자": ["상의", "하의", "어깨", "벨트", "신발"],
        "콰트로 카시테움": ["상의", "하의", "어깨", "벨트", "신발"],
        "그란테 전투기갑 파츠": ["상의", "하의", "어깨", "벨트", "신발"],
        "레거시: 마력의 소용돌이": ["상의", "하의", "어깨", "벨트", "신발"],
        "레거시: 자연의 수호자": ["상의", "하의", "어깨", "벨트", "신발"]
    };
    const ARMOR_PREFIX = {
        "어느 말괄량이의 탐사복": ["전격", "허상"],
        "포이즈닝 퀸 스파이더": ["작열", "침식"],
        "거인의 스펙쿨룸 아이언": ["수호", "왜곡"],
        "어둠을 쏘아 내리는 자": ["자상", "맹독"],
        "수호자의 초합금": ["허상", "보호"],
        "스틱키 애시드 웨펀": ["맹독", "왜곡"],
        "섬뜩한 강철 용": ["쇄도", "침식"],
        "익스플로시브 버닝 스톤": ["신속", "연격"],
        "빛의 헌신자": ["수호", "연격"],
        "여명을 쏘아 올리는 자": ["자상", "쇄도"],
        "콰트로 카시테움": ["작열", "보호"],
        "그란테 전투기갑 파츠": ["신속", "전격"],
        "레거시: 마력의 소용돌이": ["레거시"],
        "레거시: 자연의 수호자": ["레거시"]
    };
    // 레거시 장비는 접두어만 있고 일반 장비가 없음 (빈 배열)
    const ARMOR_EXCEED_ONLY = [];
    // ─────────────────────────────────────────
    // 2.2 악세 세트
    // ─────────────────────────────────────────
    const ACCESSORY_SETS = {
        "엘팅 메모리얼의 기억": ["팔찌", "목걸이", "반지"],
        "섬뜩한 빛의 관리자": ["팔찌", "목걸이", "반지"],
        "부식된 메탈기어": ["팔찌", "목걸이", "반지"],
        "화력 개조 탄띠": ["팔찌", "목걸이", "반지"],
        "신비로운 빛의 소용돌이": ["팔찌", "목걸이", "반지"],
        "콰트로 마누스 연산장치": ["팔찌", "목걸이", "반지"],
        "레거시: 에테리얼 리베넌트": ["팔찌", "목걸이", "반지"],
        "레거시: 지나온 영광의 시대": ["팔찌", "목걸이", "반지"]
    };
    const ACCESSORY_PREFIX = {
        "엘팅 메모리얼의 기억": ["견고", "혈독"],
        "섬뜩한 빛의 관리자": ["초석", "각오"],
        "부식된 메탈기어": ["각오", "가속"],
        "화력 개조 탄띠": ["혈독", "견고"],
        "신비로운 빛의 소용돌이": ["조화", "초석"],
        "콰트로 마누스 연산장치": ["가속", "조화"],
        "레거시: 에테리얼 리베넌트": ["레거시"],
        "레거시: 지나온 영광의 시대": ["레거시"]
    };
    // 레거시 장비는 접두어만 있고 일반 장비가 없음 (빈 배열)
    const ACCESSORY_EXCEED_ONLY = [];
    // ─────────────────────────────────────────
    // 2.3 특장 세트
    // ─────────────────────────────────────────
    const SPECIAL_SETS = {
        "개구쟁이 호문쿨루스": ["귀걸이", "마법석", "보장"],
        "라이트닝 에너지 코어": ["귀걸이", "마법석", "보장"],
        "철갑을 두른 탑의 수호꾼": ["귀걸이", "마법석", "보장"],
        "깊은 불구덩이의 섬멸자": ["귀걸이", "마법석", "보장"],
        "허영 속 어둠의 피조물": ["귀걸이", "마법석", "보장"],
        "부정한 빛의 우상": ["귀걸이", "마법석", "보장"]
    };
    const SPECIAL_PREFIX = {
        "개구쟁이 호문쿨루스": ["불굴", "숙련"],
        "라이트닝 에너지 코어": ["숙련", "결의"],
        "철갑을 두른 탑의 수호꾼": ["격변", "촉진"],
        "깊은 불구덩이의 섬멸자": ["불굴", "촉진"],
        "허영 속 어둠의 피조물": ["질주", "결의"],
        "부정한 빛의 우상": ["질주", "격변"]
    };
    const ALL_SETS = {...ARMOR_SETS, ...ACCESSORY_SETS, ...SPECIAL_SETS};
    const ALL_PREFIX = {...ARMOR_PREFIX, ...ACCESSORY_PREFIX, ...SPECIAL_PREFIX};

    // ★ 레거시 세트: 접두어는 "레거시"지만 키는 setName 자체를 그대로 사용
    // e.g., makePrefixKey("레거시", "레거시: 마력의 소용돌이") => "레거시: 마력의 소용돌이"
    // (NOT "레거시: 레거시: 마력의 소용돌이")
    const LEGACY_PREFIX_SETS = [
        "레거시: 마력의 소용돌이",
        "레거시: 자연의 수호자",
        "레거시: 에테리얼 리베넌트",
        "레거시: 지나온 영광의 시대"
    ];

    function makePrefixKey(pref, setName) {
        if (LEGACY_PREFIX_SETS.includes(setName)) return setName;
        return `${pref}: ${setName}`;
    }

    // ─────────────────────────────────────────
    // 2.4 익시드 관련
    // ─────────────────────────────────────────
    const EXCEED_TAGS = ["선봉", "의지", "이상"];
    const EXCEED_SLOTS = {"ARMOR": ["상의"], "ACCESSORY": ["팔찌"], "SPECIAL": ["귀걸이"]};
    const EXCEED_COLOR_MAP = {
        "선봉": "#ff4d4d",
        "의지": "#4d94ff",
        "이상": "#2ecc71"
    };

    // ─────────────────────────────────────────
    // 2.5 표시용 이름 매핑
    // ─────────────────────────────────────────
    const ARMOR_DISPLAY_NAMES = {
        "어느 말괄량이의 탐사복": {
            "상의": ["못말리는 말괄량이의 가죽", "어느 말괄량이의 가죽 자켓"],
            "하의": "어느 말괄량이의 버블 반바지",
            "어깨": "어느 말괄량이의 특수 고글",
            "벨트": "어느 말괄량이의 벨트",
            "신발": "어느 말괄량이의 신발"
        },
        "포이즈닝 퀸 스파이더": {
            "상의": ["엠프리스 스파이더 상의", "퀸 스파이더 상의"],
            "하의": "퀸 스파이더 하의",
            "어깨": "퀸 스파이더 머리",
            "벨트": "퀸 스파이더 벨트 장식",
            "신발": "퀸 스파이더 신발"
        },
        "거인의 스펙쿨룸 아이언": {
            "상의": ["거신의 스펙쿨룸 상의", "거인의 스펙쿨룸 상의"],
            "하의": "거인의 스펙쿨룸 하의",
            "어깨": "거인의 스펙쿨룸 어깨 장식",
            "벨트": "거인의 스펙쿨룸 허리띠",
            "신발": "거인의 스펙쿨룸 신발"
        },
        "어둠을 쏘아 내리는 자": {
            "상의": ["밤을 쏘아 내리는 자의 상의", "어둠을 쏘아 내리는 자의 상의"],
            "하의": "어둠을 쏘아 내리는 자의 하의",
            "어깨": "어둠을 쏘아 내리는 자의 어깨 덧댐",
            "벨트": "어둠을 쏘아 내리는 자의 허리띠",
            "신발": "어둠을 쏘아 내리는 자의 신발"
        },
        "수호자의 초합금": {
            "상의": ["수호군주의 초합금 상의", "수호자의 초합금 상의"],
            "하의": "수호자의 초합금 하의",
            "어깨": "수호자의 초합금 어깨",
            "벨트": "수호자의 초합금 벨트",
            "신발": "수호자의 초합금 신발"
        },
        "스틱키 애시드 웨펀": {
            "상의": ["네트 스파이더 상의", "웹 스파이더의 상의"],
            "하의": "웹 스파이더의 하의",
            "어깨": "웹 스파이더의 어깨",
            "벨트": "웹 스파이더의 허리",
            "신발": "웹 스파이더의 신발"
        },
        "섬뜩한 강철 용": {
            "상의": ["강철 용의 스케일 재킷", "강철 용의 가죽 재킷"],
            "하의": "강철 용의 가죽 그리브",
            "어깨": "강철 용의 뿔 장식",
            "벨트": "강철 용의 휴대용 벨트",
            "신발": "강철 용의 가죽 신발"
        },
        "익스플로시브 버닝 스톤": {
            "상의": ["블레이징 기어 플레이트 메일", "버닝 기어 플레이트 메일"],
            "하의": "버닝 기어 플레이트 레깅스",
            "어깨": "버닝 기어 플레이트 햇",
            "벨트": "버닝 기어 플레이트 코일",
            "신발": "버닝 기어 플레이트 사바톤"
        },
        "빛의 헌신자": {
            "상의": ["빛의 수호자의 상의", "빛의 헌신자의 상의"],
            "하의": "빛의 헌신자의 하의",
            "어깨": "빛의 헌신자의 모자",
            "벨트": "빛의 헌신자의 허리장식",
            "신발": "빛의 헌신자의 신발"
        },
        "여명을 쏘아 올리는 자": {
            "상의": ["여명을 밝힌 자의 상의", "여명을 쏘아 올리는 자의 상의"],
            "하의": "여명을 쏘아 올리는 자의 바지",
            "어깨": "여명을 쏘아 올리는 자의 어깨 덧댐",
            "벨트": "여명을 쏘아 올리는 자의 허리띠",
            "신발": "여명을 쏘아 올리는 자의 신발"
        },
        "콰트로 카시테움": {
            "상의": ["콰트로 카시테움 아머Mk2", "콰트로 카시테움 아머"],
            "하의": "콰트로 카시테움 각반",
            "어깨": "콰트로 카시테움 새로운 손",
            "벨트": "콰트로 카시테움 코일",
            "신발": "콰트로 카시테움 그리브"
        },
        "그란테 전투기갑 파츠": {
            "상의": ["그런데 마누스 전투기갑 상의", "그란데 전투기갑 상의"],
            "하의": "그란데 전투기갑 하의",
            "어깨": "그란데 전투기갑 헤드기어",
            "벨트": "그란데 전투기갑 허리",
            "신발": "그란데 전투기갑 신발"
        },
        "레거시: 마력의 소용돌이": {
            "상의": ["휘몰아치는 마력의 태풍", "마력의 폭풍우"],
            "하의": "영력의 회오리",
            "어깨": "마법의 대격변",
            "벨트": "마나의 소용돌이",
            "신발": "정수의 태풍"
        },
        "레거시: 자연의 수호자": {
            "상의": ["루미너스 오토 상의", "라이트니스 오토 상의"],
            "하의": "파이어니스 오토 하의",
            "어깨": "블랙니스 오토 어깨",
            "벨트": "아이니스 오토 벨트",
            "신발": "윈드니스 오토 신발"
        }
    };

    // 악세 표시용 이름 매핑 (레거시 아이템은 "레거시: " 접두어 제거)
    const ACCESSORY_DISPLAY_NAMES = {
        "엘팅 메모리얼의 기억": {
            "팔찌": ["선명한 기억의 팔찌", "묻힌 시간의 팔찌"],
            "목걸이": "흐릿한 과거의 목걸이",
            "반지": "덮어둔 기억의 반지"
        },
        "섬뜩한 빛의 관리자": {
            "팔찌": ["이심전심", "무언의 연결"],
            "목걸이": "숨겨진 맥락",
            "반지": "감춰진 결"
        },
        "부식된 메탈기어": {
            "팔찌": ["기계의 심박", "기계의 맥박"],
            "목걸이": "사라진 동력",
            "반지": "정지된 흐름"
        },
        "화력 개조 탄띠": {
            "팔찌": ["멀티플 툴즈", "트리플 툴즈"],
            "목걸이": "피어싱 드릴 네클레스",
            "반지": "오토매틱 실린더"
        },
        "신비로운 빛의 소용돌이": {
            "팔찌": ["시린 달빛", "푸른 달빛"],
            "목걸이": "은색의 별빛",
            "반지": "붉은 햇빛"
        },
        "콰트로 마누스 연산장치": {
            "팔찌": ["기계의 주시", "기계의 시선"],
            "목걸이": "에너지의 눈",
            "반지": "응시의 흔적"
        },
        "레거시: 에테리얼 리베넌트": {
            "팔찌": ["아이언 엠벨리시드 밴드", "강철 리스트 가드"],
            "목걸이": "영혼 추적장치",
            "반지": "할기의 본링"
        },
        "레거시: 지나온 영광의 시대": {
            "팔찌": ["세이트 루멘아이트 렐릭", "홀리 미스릴 렐릭"],
            "목걸이": "펠 로스 글로리",
            "반지": "에이션트 엘븐 링"
        }
    };

    // 악세 추가 정보
    const ACCESSORY_EXTRA_INFO = {
        "엘팅 메모리얼의 기억": "선명한,묻힌 / 흐릿한 / 덮어둔",
        "섬뜩한 빛의 관리자": "이심전심,무언 / 숨겨진 / 감춰진",
        "부식된 메탈기어": "기계의 심박,맥박 / 사라진 / 정지",
        "화력 개조 탄띠": "멀티플,트리플 / 피어싱 / 오토매틱",
        "신비로운 빛의 소용돌이": "시린,푸른 / 은색 / 붉은",
        "콰트로 마누스 연산장치": "기계의 주시,시선 / 에너지 / 응시",
        "레거시: 에테리얼 리베넌트": "아이언,강철 / 영혼 / 할기",
        "레거시: 지나온 영광의 시대": "세이트,홀리 / 펠 / 에이션트"
    };

    // 특장 추가 정보
    const SPECIAL_EXTRA_INFO = {
        "개구쟁이 호문쿨루스": "말괄량이,베키",
        "라이트닝 에너지 코어": "거신,거인",
        "철갑을 두른 탑의 수호꾼": "메탈기어",
        "깊은 불구덩이의 섬멸자": "강철",
        "허영 속 어둠의 피조물": "골드",
        "부정한 빛의 우상": "콰트로"
    };

    // ✅ 새로 추가: 특수장비 표시용 이름 매핑
    const SPECIAL_DISPLAY_NAMES = {
        "개구쟁이 호문쿨루스": {
            "귀걸이": ["말괄량이의 문양 귀걸이", "베키의 문양 귀걸이"],
            "마법석": "베키의 새총",
            "보장": "베키의 장갑"
        },
        "라이트닝 에너지 코어": {
            "귀걸이": ["거신의 스펙쿨룸 이어링", "거인의 스펙쿨룸 이어링"],
            "마법석": "거인의 스펙쿨룸 코어",
            "보장": "거인의 건들릿"
        },
        "철갑을 두른 탑의 수호꾼": {
            "귀걸이": ["메탈기어의 초합금 태엽", "메탈기어의 태엽 귀걸이"],
            "마법석": "메탈기어의 두뇌",
            "보장": "메탈기어의 조작부"
        },
        "깊은 불구덩이의 섬멸자": {
            "귀걸이": ["강철 용의 기관총 이어링", "강철 용의 기총 이어링"],
            "마법석": "강철 용의 천공기",
            "보장": "강철 용의 칼날 외골격"
        },
        "허영 속 어둠의 피조물": {
            "귀걸이": ["골드 크라운의 서커스 장식", "골드 크라운의 머리 장식"],
            "마법석": "골드 크라운의 핵심 부품",
            "보장": "골드 크라운의 에너지 방출기"
        },
        "부정한 빛의 우상": {
            "귀걸이": ["콰트로 마누스의 기억", "콰트로 마누스의 태엽 장식"],
            "마법석": "콰트로 마누스의 두뇌",
            "보장": "콰트로 마누스의 에너지 코어"
        }
    };

    // ─────────────────────────────────────────
    // 2.6 무기 데이터
    // ─────────────────────────────────────────
    const WEAPON_DATA_SLAYER = {
        "소검": ["대서사의 탄생 - 소검", "암흑의 별", "왕위 계승자"],
        "도": ["대서사의 탄생 - 도", "요도 : 무라마사", "트리니티 이터니아"],
        "둔기": ["대서사의 탄생 - 둔기", "세계의 무게추", "신검의 나뭇가지"],
        "대검": ["대서사의 탄생 - 대검", "성검 : 엑스칼리버", "데빌 오브 플레어"],
        "광검": ["대서사의 탄생 - 광검", "아마 겟 돈", "뇌검 : 고룬"]
    };
    const WEAPON_DATA_FIGHTER = {
        "너클": ["대서사의 탄생 - 너클", "라오 데솔", "베르세르크"],
        "건틀릿": ["대서사의 탄생 - 건틀릿", "반격의 서막", "룰렛러시안"],
        "클로": ["대서사의 탄생 - 클로", "흑월랑아", "악마의 갈퀴 : 이그노어"],
        "권투글러브": ["대서사의 탄생 - 권투글러브", "티쥬 엠플리파이어", "파울 키드니블로"],
        "통파": ["대서사의 탄생 - 통파", "킬 아르니스 렵곡", "습격의 드라우프니르"]
    };
    const WEAPON_DATA_GUNNER = {
        "리볼버": ["대서사의 탄생 - 리볼버", "이스 미 터너", "실버 불렛"],
        "자동권총": ["대서사의 탄생 - 자동권총", "이온 리필서", "마이스터의 분노"],
        "머스켓": ["대서사의 탄생 - 머스켓", "Code N : 오라클", "블라인드 스팟"],
        "핸드캐넌": ["대서사의 탄생 - 핸드캐넌", "거포 우르반", "해를 먹는 자"],
        "보우건": ["대서사의 탄생 - 보우건", "데스 리뷰저", "제너럴 보우건"]
    };
    const WEAPON_DATA_MAGE = {
        "창": ["대서사의 탄생 - 창", "쥬빌런스 혼", "전장의 여신의 창"],
        "봉": ["대서사의 탄생 - 봉", "케세라세라 : 해피 ~!", "요정왕의 비밀"],
        "로드": ["대서사의 탄생 - 로드", "히어로 오브 더 문", "양치기의 로드"],
        "스태프": ["대서사의 탄생 - 스태프", "웨리 : 리미트 브레이커", "창마화의 연"],
        "빗자루": ["대서사의 탄생 - 빗자루", "보배 - 파초선", "스노우 프린세스"]
    };
    const WEAPON_DATA_PRIEST = {
        "십자가": ["대서사의 탄생 - 십자가", "헤이렐 - 교만의 빛", "저주 받은 십자가 : 토루아"],
        "염주": ["대서사의 탄생 - 염주", "음양사천", "명인의 수"],
        "토템": ["대서사의 탄생 - 토템", "씰 더 리바이어던", "풍운뇌우"],
        "낫": ["대서사의 탄생 - 낫", "소울 디바우링", "선고 : 사신의 낫"],
        "배틀엑스": ["대서사의 탄생 - 배틀엑스", "행성파괴자", "오만의 끝"]
    };
    const WEAPON_DATA_WARRIOR = {
        "락소드": ["대서사의 탄생 - 락소드", "우주적 기운의 락소드", "라이프 파인더"],
        "윙블레이드": ["대서사의 탄생 - 윙블레이드", "프로스트 윙 블레이드", "코카트리스"]
    };
    const WEAPON_DATA_LANCER = {
        "미늘창": ["대서사의 탄생 - 미늘창", "크림슨 로드", "광염의 극"],
        "투창": ["대서사의 탄생 - 투창", "헬 오브 데빌로드", "미라클 런치"]
    };
    const WEAPON_DATA_THIEF = {
        "단검": ["대서사의 탄생 - 단검", "실버 스피릿", "월광검"],
        "쌍검": ["대서사의 탄생 - 쌍검", "흑미쌍검", "히게-히자키리"],
        "차크라웨펀": ["대서사의 탄생 - 차크라웨펀", "크리드 오브 닌자", "무염화"]
    };
    const WEAPON_PREFIXES = [
        {tag: "[광채]", color: "#3399cc"}, // 파란색
        {tag: "[분쇄]", color: "#ff4d4f"}, // 빨간색
        {tag: "[선명]", color: "#25c2a0"}, // 초록색
        {tag: "[강타]", color: "#ffd700"}  // 노란색
    ];
    const WEAPON_DATA_MAP = {
        '귀검사': WEAPON_DATA_SLAYER,
        '격투가': WEAPON_DATA_FIGHTER,
        '거너': WEAPON_DATA_GUNNER,
        '마법사': WEAPON_DATA_MAGE,
        '프리스트': WEAPON_DATA_PRIEST,
        '워리어': WEAPON_DATA_WARRIOR,
        '마창사': WEAPON_DATA_LANCER,
        '도적': WEAPON_DATA_THIEF
    };
    const JOB_LIST = Object.keys(WEAPON_DATA_MAP);

    /* ========================================
           [섹션 3] 초기 캐릭터 데이터
           ======================================== */
    let characters = [
        {
            id: "c1", job: "검귀", name: "강의", armorCounts: {
                "어느 말괄량이의 탐사복 상의": 1,
                "어느 말괄량이의 탐사복 하의": 1,
                "어느 말괄량이의 탐사복 어깨": 1,
                "엘팅 메모리얼의 기억 팔찌": 1,
                "[의지] 견고: 엘팅 메모리얼의 기억 팔찌": 1,
                "개구쟁이 호문쿨루스 귀걸이": 1
            }, updateTimes: { // 💡 추가된 필드: 아이템별 업데이트 시간 저장
                "어느 말괄량이의 탐사복 상의": Date.now() - 50000,
                "어느 말괄량이의 탐사복 하의": Date.now() - 40000,
                "어느 말괄량이의 탐사복 어깨": Date.now() - 30000,
                "엘팅 메모리얼의 기억 팔찌": Date.now() - 20000,
                "[의지] 견고: 엘팅 메모리얼의 기억 팔찌": Date.now() - 10000,
                "개구쟁이 호문쿨루스 귀걸이": Date.now()
            }
        }
    ];

    // 전역 최대 길이
    let globalSetNameWidth = 200;
    let globalSlotWidth = 100;


    /* ========================================
       [섹션 4] 데이터 관리 (로컬 스토리지)
       ======================================== */
    // 데이터 저장 시
    /*
        [
          {
            "id": "c1234567890",
            "name": "강의",
            "job": "검귀",
            "armorCounts": {...},
            "updateTimes": {...},
            "createdOrder": 0
          },
          {
            "id": "c1234567891",
            "name": "철수",
            "job": "격투가",
            "createdOrder": 1
          }
        ]
     */
    function saveLocalData() {
        localStorage.setItem("dnfm_eq", JSON.stringify(characters));
    }

    // 데이터 로드 시 (초기화 로직 포함)
    function loadLocalData() {
        const saved = localStorage.getItem("dnfm_eq");
        if (saved) {
            try {
                characters = JSON.parse(saved);
            } catch (e) {
                console.error("데이터 로드 실패", e);
                characters = [];
            }
        }
    }

    /* ========================================
       [섹션 5] 초기 계산 함수
       ======================================== */
    function calculateGlobalWidths() {
        const allNames = [], allSlots = [];
        [{sets: ARMOR_SETS, pref: ARMOR_PREFIX},
            {sets: ACCESSORY_SETS, pref: ACCESSORY_PREFIX},
            {sets: SPECIAL_SETS, pref: SPECIAL_PREFIX}].forEach(({sets, pref}) => {
            Object.keys(sets).forEach(setName => {
                allNames.push(setName);
                const prefixes = pref[setName] || [];
                prefixes.forEach(p => {
                    allNames.push(`${p}: ${setName}`);
                    EXCEED_TAGS.forEach(ex => allNames.push(`[${ex}] ${p}: ${setName}`));
                });
                sets[setName].forEach(slot => allSlots.push(slot));
            });
        });
        globalSetNameWidth = Math.max(...allNames.map(n => n.length)) * 12;
        globalSlotWidth = Math.max(...allSlots.map(s => s.length)) * 12;
    }

    /* ========================================
       [섹션 6] 유틸리티 함수
       ======================================== */
    // 표에 들어갈 행 이름 배열을 받아 가장 긴 이름 기준으로 너비(px) 계산
    function calcNameWidth(names) {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        ctx.font = "14px sans-serif";
        const max = Math.max(...names.map(n => ctx.measureText(n).width));
        return Math.ceil(max) + 24;
    }

    /**
     * 장비 테이블 행 생성 공통 함수
     */
    function createEquipmentRow(config) {
        const {
            char, setName, nameKey, labelText, slots, fullSize
        } = config;

        const totalDistinct = getCachedDistinctParts(char, setName);
        let hasAnyPart = false;

        slots.forEach(slot => {
            if ((char.armorCounts[`${nameKey} ${slot}`] || 0) > 0) {
                hasAnyPart = true;
            }
        });

        const tr = document.createElement("tr");

        if (hasAnyPart) {
            if (fullSize === 5) {
                if (totalDistinct === fullSize) tr.className = "set5";
                else if (totalDistinct >= 3) tr.className = "set3";
            } else {
                if (totalDistinct === 3) tr.className = "set3";
            }
        }

        let html = `<td style="text-align:center;">${labelText}</td>`;
        slots.forEach(slot => {
            const key = `${nameKey} ${slot}`;
            const val = char.armorCounts[key] || 0;
            html += `<td>${makeNumberButton(char.id, key, val)}</td>`;
        });

        tr.innerHTML = html;
        return tr;
    }

    /**
     * 익시드 태그 색상 가져오기
     */
    function getExceedColor(tag) {
        const cleanTag = tag.replace(/[\[\]]/g, '');
        return EXCEED_COLOR_MAP[cleanTag] || '#ffd700';
    }

    /**
     * 익시드/접두어가 포함된 이름을 HTML로 변환
     */
    function formatEquipmentName(name) {
        let html = '';

        const exceedMatch = name.match(/^(\[.*?\])\s*(.*)/);
        if (exceedMatch) {
            const tag = exceedMatch[1];
            const rest = exceedMatch[2];
            const color = getExceedColor(tag);
            html += `<span style="color:${color}; font-weight:bold;">${tag}</span> `;
            name = rest;
        }

        const prefixMatch = name.match(/^(.+?):\s*(.+)/);
        if (prefixMatch) {
            const prefix = prefixMatch[1];
            const base = prefixMatch[2];
            html += `<span style="color:#e6b800; font-weight:bold;">${prefix}</span>: ${base}`;
        } else {
            html += name;
        }

        return html;
    }

    function isExceedName(name) {
        return /^\[(선봉|의지|이상)\]\s/.test(name);
    }

    function getGroupKey(name) {
        return name.replace(/^\[.*?\]\s*/, "");
    }

    function getSetType(setName) {
        if (ARMOR_SETS[setName]) return "ARMOR";
        if (ACCESSORY_SETS[setName]) return "ACCESSORY";
        if (SPECIAL_SETS[setName]) return "SPECIAL";

        // 접두어나 익시드가 붙은 이름에서 기본 세트명을 추출하여 판별
        const baseName = setName.includes(':') ? setName.split(':').pop().trim() : setName;
        if (ARMOR_SETS[baseName]) return "ARMOR";
        if (ACCESSORY_SETS[baseName]) return "ACCESSORY";
        if (SPECIAL_SETS[baseName]) return "SPECIAL";

        // 레거시 세트 판별 (setName 자체가 키)
        for (const legacyName of LEGACY_PREFIX_SETS) {
            if (setName === legacyName || setName.endsWith(legacyName)) {
                if (ARMOR_SETS[legacyName]) return "ARMOR";
                if (ACCESSORY_SETS[legacyName]) return "ACCESSORY";
            }
        }

        return "ARMOR";
    }

    // 캐시 키 생성
    function makeDistinctCacheKey(char, setName) {
        return `${char.id}|${setName}`;
    }

    // 캐시 무효화 (데이터 변경 시)
    function invalidateDistinctCache(charId, setName) {
        if (setName) {
            // 특정 세트만 무효화
            const key = `${charId}|${setName}`;
            delete distinctPartsCache[key];
        } else {
            // 해당 캐릭터의 모든 캐시 무효화
            Object.keys(distinctPartsCache).forEach(key => {
                if (key.startsWith(`${charId}|`)) {
                    delete distinctPartsCache[key];
                }
            });
        }
    }

    // 캐시된 결과 가져오기
    function getCachedDistinctParts(char, setName) {
        const cacheKey = makeDistinctCacheKey(char, setName);

        // 캐시에 있으면 반환
        if (distinctPartsCache[cacheKey] !== undefined) {
            return distinctPartsCache[cacheKey];
        }

        // 없으면 계산 후 저장
        const result = calcTotalDistinctParts(char, setName);
        distinctPartsCache[cacheKey] = result;
        return result;
    }

    function calcTotalDistinctParts(char, baseSetName) {
        const slots = ALL_SETS[baseSetName] || [];
        const prefixes = ALL_PREFIX[baseSetName] || [];
        const setType = getSetType(baseSetName);
        const exceedSlots = EXCEED_SLOTS[setType] || [];

        // 검색할 모든 그룹 이름 (기본, 접두어, 익시드) 생성
        const namesToSearch = [];

        // 레거시 세트는 일반 행 없음 (접두어만)
        if (!LEGACY_PREFIX_SETS.includes(baseSetName)) {
            namesToSearch.push(baseSetName);
        }

        prefixes.forEach(p => {
            const prefKey = makePrefixKey(p, baseSetName);
            namesToSearch.push(prefKey);
            EXCEED_TAGS.forEach(ex => namesToSearch.push(`[${ex}] ${prefKey}`));
        });

        let totalDistinct = 0;

        slots.forEach(slot => {
            let hasPartInSlot = false;

            namesToSearch.forEach(nameComponent => {
                const isExceedKey = nameComponent.startsWith('[');

                // 익시드 키는 특정 슬롯에만 존재하므로, 아닌 경우는 건너뜁니다.
                if (isExceedKey && !exceedSlots.includes(slot)) {
                    return;
                }

                const fullKey = `${nameComponent} ${slot}`;
                if ((char.armorCounts[fullKey] || 0) > 0) {
                    hasPartInSlot = true;
                }
            });

            if (hasPartInSlot) {
                totalDistinct++;
            }
        });

        return totalDistinct;
    }

    /* ========================================
       [섹션 7] 캐릭터 관리
       ======================================== */

    // ─────────────────────────────────────────
    // 7.1 캐릭터 CRUD
    // ─────────────────────────────────────────
    function addCharacter() {
        const name = document.getElementById("newCharName").value.trim();
        const job = document.getElementById("newCharJob").value.trim();
        if (!name || !job) {
            alert("이름과 직업을 입력하세요!");
            return;
        }

        const newChar = {
            id: "c" + Date.now(),
            job: job,
            name: name,
            armorCounts: {},
            updateTimes: {},
            craftMaterials: {}  // 👈 추가
        };

        characters.push(newChar);
        saveLocalData();
        renderCharacterList();
        document.getElementById("newCharName").value = "";
        document.getElementById("newCharJob").value = "";
    }

    // 인자 순서가 중요합니다: (캐릭터ID, 수정된이름, 수정된직업)
    function updateCharacterInfo(charId) {
        // 🚨 787번 줄 수정: charName 대신 edit-charName을 찾습니다.
        const nameInput = document.getElementById("edit-charName");
        const jobInput = document.getElementById("edit-charJob");

        // 요소가 존재하는지 확인하여 null 에러 방지
        if (!nameInput || !jobInput) {
            alert("수정 입력창을 찾을 수 없습니다.");
            return;
        }

        const newName = nameInput.value.trim();
        const newJob = jobInput.value.trim();

        if (!newName || !newJob) {
            alert("이름과 직업을 모두 입력해 주세요.");
            return;
        }

        const char = characters.find(c => c.id === charId);
        if (char) {
            char.name = newName;
            char.job = newJob;

            saveLocalData();
            renderCharacterList(); // 리스트 갱신
            closeActionModal();    // 모달 닫기
            alert("정보가 수정되었습니다.");
        }
    }


    function deleteCharacterConfirmed() {
        openConfirmModal(
            "캐릭터 삭제",
            "정말로 이 캐릭터를 삭제하시겠습니까?\n삭제된 데이터는 복구할 수 없습니다.",
            function () {
                // 1. 전역 배열에서 해당 캐릭터 제외 (필터링)
                characters = characters.filter(c => String(c.id) !== String(currentActionCharId));

                // 2. 💡 수정 포인트: saveData 대신 실제 존재하는 saveLocalData 호출
                saveLocalData();

                // 3. 화면 UI 갱신 (리스트 다시 그리기)
                renderCharacterList();

                // 4. 삭제한 캐릭터가 현재 선택된 캐릭터였다면 상세 화면도 비우기
                if (activeCharacterId === currentActionCharId) {
                    const setListEl = document.getElementById("setList");
                    const panelEl = document.getElementById("panel");
                    if (setListEl) setListEl.innerHTML = "";
                    if (panelEl) panelEl.innerHTML = "";
                    activeCharacterId = null;
                }

                // 5. 마무리
                closeActionModal();
                alert("삭제되었습니다.");
            }
        );
    }

    function resetCharacterStatsConfirmed() {
        const targetId = currentActionCharId;

        if (!targetId) {
            alert("대상 캐릭터를 선택할 수 없습니다.");
            return;
        }

        openConfirmModal(
            "수치 초기화",
            "이 캐릭터의 모든 장비 보유 현황 및 업데이트 기록을 초기화하시겠습니까?",
            function () {
                // 1. 캐릭터 데이터 찾기
                const char = characters.find(c => String(c.id) === String(targetId));

                if (char) {
                    // 2. 💡 핵심: 사용자님의 데이터 필드명(armorCounts, updateTimes)을 초기화합니다.
                    char.armorCounts = {};
                    char.updateTimes = {};

                    // 무기 정보가 있다면 함께 초기화
                    if (char.weaponCounts) char.weaponCounts = {};

                    // 3. 로컬 스토리지에 즉시 저장
                    saveLocalData();

                    // 4. 화면 UI 갱신
                    if (typeof renderCharacterList === "function") renderCharacterList();

                    // 5. 상세 보기 영역 비우기 (초기화되었으므로 이전 정보를 지웁니다)
                    const setListEl = document.getElementById("setList");
                    const panelEl = document.getElementById("panel");
                    if (setListEl) setListEl.innerHTML = "";
                    if (panelEl) panelEl.innerHTML = "";

                    activeCharacterId = null; // 선택 상태 해제

                    alert("모든 수치가 초기화되었습니다.");
                    closeActionModal(); // 설정 창 닫기
                } else {
                    alert("캐릭터 데이터를 찾을 수 없습니다.");
                }
            }
        );
    }

    // ─────────────────────────────────────────
    // 7.2 캐릭터 렌더링
    // ─────────────────────────────────────────
    function renderCharacterList() {
        const listEl = document.getElementById("characterList");
        if (!listEl) return;

        listEl.innerHTML = "";

        characters.forEach((c, index) => {
            const wrapper = document.createElement("div");
            wrapper.className = "character-wrapper";
            wrapper.style.display = "inline-flex";
            wrapper.style.alignItems = "center";
            wrapper.style.marginRight = "10px";
            wrapper.style.marginBottom = "10px";

            // 캐릭터 버튼
            const btn = document.createElement("button");
            btn.className = "char-btn" + (c.id === activeCharacterId ? " active" : "");
            btn.textContent = `${c.job} (${c.name})`;
            btn.onclick = () => {
                if (typeof showSetButtons === "function") showSetButtons(c);
            };

            // ⚙️ 설정 버튼
            const settingsBtn = document.createElement("button");
            settingsBtn.textContent = "⚙️";
            settingsBtn.className = "settings-btn";
            settingsBtn.onclick = (e) => {
                e.stopPropagation();
                openActionModal(c.id, c.name, c.job);
            };

            wrapper.appendChild(btn);
            wrapper.appendChild(settingsBtn);

            // // ✅ 편집 모드일 때만 ⬆️⬇️ 버튼 표시
            // if (isEditingCharacterOrder) {
            //     // ⬆️ 위로 버튼
            //     const upBtn = document.createElement("button");
            //     upBtn.textContent = "⬆️";
            //     upBtn.className = "settings-btn";
            //     upBtn.title = "위로 이동";
            //     upBtn.onclick = (e) => {
            //         e.stopPropagation();
            //         moveCharacterUp(index);
            //     };
            //     if (index === 0) {
            //         upBtn.disabled = true;
            //         upBtn.style.opacity = "0.3";
            //         upBtn.style.cursor = "not-allowed";
            //     }
            //
            //     // ⬇️ 아래로 버튼
            //     const downBtn = document.createElement("button");
            //     downBtn.textContent = "⬇️";
            //     downBtn.className = "settings-btn";
            //     downBtn.title = "아래로 이동";
            //     downBtn.onclick = (e) => {
            //         e.stopPropagation();
            //         moveCharacterDown(index);
            //     };
            //     if (index === characters.length - 1) {
            //         downBtn.disabled = true;
            //         downBtn.style.opacity = "0.3";
            //         downBtn.style.cursor = "not-allowed";
            //     }
            //
            //     wrapper.appendChild(upBtn);
            //     wrapper.appendChild(downBtn);
            // }

            // ✅ 편집 모드일 때만 ⬅️➡️ 버튼 표시
            if (isEditingCharacterOrder) {
                // ⬅️ 왼쪽(위로) 버튼
                const leftBtn = document.createElement("button");
                leftBtn.textContent = "⬅️";
                leftBtn.className = "settings-btn";
                leftBtn.title = "왼쪽으로 이동";
                leftBtn.onclick = (e) => {
                    e.stopPropagation();
                    moveCharacterUp(index);
                };
                if (index === 0) {
                    leftBtn.disabled = true;
                    leftBtn.style.opacity = "0.3";
                    leftBtn.style.cursor = "not-allowed";
                }

                // ➡️ 오른쪽(아래로) 버튼
                const rightBtn = document.createElement("button");
                rightBtn.textContent = "➡️";
                rightBtn.className = "settings-btn";
                rightBtn.title = "오른쪽으로 이동";
                rightBtn.onclick = (e) => {
                    e.stopPropagation();
                    moveCharacterDown(index);
                };
                if (index === characters.length - 1) {
                    rightBtn.disabled = true;
                    rightBtn.style.opacity = "0.3";
                    rightBtn.style.cursor = "not-allowed";
                }

                wrapper.appendChild(leftBtn);
                wrapper.appendChild(rightBtn);
            }

            listEl.appendChild(wrapper);
        });
    }

    // ─────────────────────────────────────────
    // 7.3 순서 관리
    // ─────────────────────────────────────────
    function saveCurrentOrder() {
        characters.forEach((char, index) => {
            char.createdOrder = index;                       // 현재 인덱스를 등록 순서로 저장
        });

        saveLocalData();                                     // 로컬 스토리지에 저장
        alert('✅ 현재 순서가 등록되었습니다!');
    }

    // 💡 등록 순서로 복원
    function resetToOriginalOrder() {
        if (characters.length === 0) {
            alert('캐릭터가 없습니다.');
            return;
        }

        // createdOrder가 없는 캐릭터 확인
        const hasUndefinedOrder = characters.some(
            char => char.createdOrder === undefined
        );

        if (hasUndefinedOrder) {
            alert('⚠️ 먼저 "순서 등록" 버튼을 눌러주세요!');
            return;
        }

        // 🎯 핵심: createdOrder 기준으로 정렬
        characters.sort((a, b) => {
            const orderA = a.createdOrder !== undefined ? a.createdOrder : 9999;
            const orderB = b.createdOrder !== undefined ? b.createdOrder : 9999;
            return orderA - orderB;                          // 오름차순 정렬
        });

        saveLocalData();
        renderCharacterList();

        alert('🔄 등록했던 순서로 복원되었습니다!');
    }

    // 💡 이름순 정렬
    function sortCharactersByName() {
        if (characters.length === 0) return;
        characters.sort((a, b) => a.name.localeCompare(b.name, 'ko-KR')); // 한글 가나다순
        saveLocalData();
        renderCharacterList();

        alert('이름순으로 정렬되었습니다.');
    }

    // 💡 직업순 정렬
    function sortCharactersByJob() {
        if (characters.length === 0) return;

        characters.sort((a, b) => {
            const jobCompare = a.job.localeCompare(b.job, 'ko-KR');
            if (jobCompare !== 0) return jobCompare;         // 직업이 다르면 직업순
            return a.name.localeCompare(b.name, 'ko-KR');    // 직업이 같으면 이름순
        });

        saveLocalData();
        renderCharacterList();

        alert('직업순으로 정렬되었습니다.');
    }

    // 5-4. 캐릭터 순서 변경 (↑↓ 버튼)
    function moveCharacterUp(index) {
        if (index === 0) return; // 첫 번째는 위로 갈 수 없음

        // 배열에서 위치 교환
        [characters[index], characters[index - 1]] = [characters[index - 1], characters[index]];

        saveLocalData();
        renderCharacterList();

        // 현재 선택된 캐릭터 유지
        if (activeCharacterId) {
            const activeChar = characters.find(c => c.id === activeCharacterId);
            if (activeChar) showSetButtons(activeChar, true);
        }
    }

    function moveCharacterDown(index) {
        if (index === characters.length - 1) return; // 마지막은 아래로 갈 수 없음

        // 배열에서 위치 교환
        [characters[index], characters[index + 1]] = [characters[index + 1], characters[index]];

        saveLocalData();
        renderCharacterList();

        // 현재 선택된 캐릭터 유지
        if (activeCharacterId) {
            const activeChar = characters.find(c => c.id === activeCharacterId);
            if (activeChar) showSetButtons(activeChar, true);
        }
    }

    // 5-5. 편집 모드 토글
    function toggleEditMode() {
        const editBtn = document.getElementById("edit-order-btn");

        isEditingCharacterOrder = !isEditingCharacterOrder;

        if (isEditingCharacterOrder) {
            // 편집 모드 활성화
            editBtn.textContent = "✅ 변경완료";
            editBtn.style.background = "linear-gradient(135deg, #25c2a0, #1a8c7d)";
        } else {
            // 편집 모드 비활성화
            editBtn.textContent = "✏️ 편집";
            editBtn.style.background = "linear-gradient(135deg, #3399cc, #2a6f9e)";

            // 데이터 저장
            saveLocalData();
            alert("순서 변경이 완료되었습니다!");
        }

        // 캐릭터 리스트 다시 렌더링
        renderCharacterList();
    }

    /* ========================================
       [섹션 8] 모달 관리
       ======================================== */
    function openActionModal(charId, name, job) {
        // 1. 현재 작업 대상 ID를 전역 변수에 저장
        currentActionCharId = charId;

        const modal = document.getElementById("actionModal");
        // 💡 수정 포인트: modal 자체가 null인지 확인하고, 내부 content 영역을 안전하게 참조합니다.
        if (!modal) return;

        // 사용자님의 HTML 구조에 맞춰 클래스명이 modal-content인 요소를 찾습니다.
        const content = modal.querySelector(".modal-content");
        if (!content) return;

        // 2. 모달 내부 UI 생성 (사용자님 코드 유지 + 오타 방지)
        content.innerHTML = `
      <h2 style="margin-bottom:25px; color:#fff;">캐릭터 설정 수정</h2>

      <div style="margin-bottom:15px; display:flex; align-items:center;">
          <label style="width:60px; font-weight:bold; color:#ccc;">이름 :</label>
          <input type="text" id="edit-charName" value="${name}"
                 style="flex:1; padding:8px; background:#181c33; color:#fff; border:1px solid #2a3158; border-radius:4px;">
      </div>

      <div style="margin-bottom:25px; display:flex; align-items:center;">
          <label style="width:60px; font-weight:bold; color:#ccc;">직업 :</label>
          <input type="text" id="edit-charJob" value="${job}"
                 style="flex:1; padding:8px; background:#181c33; color:#fff; border:1px solid #2a3158; border-radius:4px;">
      </div>

      <div class="modal-options" style="display:flex; flex-direction:column; gap:10px;">
          <button type="button" class="modal-btn" style="background:#25c2a0; font-weight:bold; color:#fff;"
                  onclick="updateCharacterInfo('${charId}')">정보 수정 완료</button>
          <div style="display:flex; gap:8px;">
              <button type="button" class="modal-btn" style="flex:1; background:#f39c12; font-size:0.9em; color:#fff;"
                      onclick="resetCharacterStatsConfirmed()">수치 초기화</button>
              <button type="button" class="modal-btn" style="flex:1; background:#e74c3c; font-size:0.9em; color:#fff;"
                      onclick="deleteCharacterConfirmed()">캐릭터 삭제</button>
          </div>
          <button type="button" class="modal-btn" style="background:#444; color:#fff;" onclick="closeActionModal()">취소</button>
      </div>
  `;
        modal.style.display = "flex";
    }

    // 모달 닫기 함수가 없다면 아래를 추가하세요.
    function closeActionModal() {
        const modal = document.getElementById("actionModal");
        if (modal) modal.style.display = "none";
    }

    // 확인 모달 열기 함수 (에러 방지용 보완)
    function openConfirmModal(title, message, onConfirm) {
        const modal = document.getElementById("confirmModal");
        const titleEl = document.getElementById("confirmTitle");
        const messageEl = document.getElementById("confirmMessage");
        const confirmBtn = document.getElementById("confirmYes");

        if (!modal || !titleEl || !messageEl || !confirmBtn) return;

        titleEl.textContent = title;
        messageEl.textContent = message;

        // 💡 핵심 수정: onclick에 함수를 직접 할당합니다.
        confirmBtn.onclick = function () {
            if (typeof onConfirm === "function") {
                onConfirm(); // 여기서 전달받은 함수를 실행합니다.
            }
            closeConfirmModal();
        };

        modal.style.display = 'flex';
    }

    // 모달 닫기 (기존 코드와 동일)
    function closeConfirmModal() {
        const modal = document.getElementById("confirmModal");
        if (modal) modal.style.display = 'none';
    }

    /* ========================================
       [섹션 9] 장비 관리 (세트 시스템)
       ======================================== */

    // ─────────────────────────────────────────
    // 9.1 세트 버튼 관리
    // ─────────────────────────────────────────
    // ===== 세트 버튼 표시 =====
    function showSetButtons(char, isRefresh = false) {
        const setList = document.getElementById("setList");
        const panel = document.getElementById("panel");

        // 1. [토글 로직]
        // 새로고침(isRefresh=true)이 아닐 때만 '이미 열린 캐릭터'를 누르면 닫히게 합니다.
        if (!isRefresh && activeCharacterId === char.id) {
            activeCharacterId = null;
            setList.innerHTML = "";
            panel.innerHTML = "";
            renderCharacterList(); // 선택 표시(노란불) 해제
            return;
        }

        // 캐릭터 선택 상태 업데이트 및 노란색 불 켜기
        activeCharacterId = char.id;
        renderCharacterList();

        setList.innerHTML = "";

        // ----------------------------------------------------
        // 1. 각 카테고리별 아이템 총 개수 계산
        // ----------------------------------------------------
        let totalArmor = 0;
        let totalAccessory = 0;
        let totalSpecial = 0;

        Object.entries(char.armorCounts).forEach(([fullKey, count]) => {
            if (count <= 0) return;

            const parts = fullKey.split(' ');
            const slot = parts.pop();
            const name = parts.join(' ');

            const groupKey = getGroupKey(name);
            const setType = getSetType(groupKey);

            if (setType === "ARMOR") totalArmor += count;
            else if (setType === "ACCESSORY") totalAccessory += count;
            else if (setType === "SPECIAL") totalSpecial += count;
        });

        // ----------------------------------------------------
        // 2. 제목에 총 개수를 포함하여 표시
        // ----------------------------------------------------

        // 방어구
        const armorTitle = document.createElement("h2");
        armorTitle.textContent = `[방어구 (${totalArmor}개)]`;
        setList.appendChild(armorTitle);
        Object.keys(ARMOR_SETS).forEach(setName => {
            setList.appendChild(makeSetButton(setName, char));
        });

        // 악세
        const accTitle = document.createElement("h2");
        accTitle.textContent = `[악세 (${totalAccessory}개)]`;
        setList.appendChild(accTitle);
        Object.keys(ACCESSORY_SETS).forEach(setName => {
            setList.appendChild(makeSetButton(setName, char));
        });

        // 특장
        const spTitle = document.createElement("h2");
        spTitle.textContent = `[특장 (${totalSpecial}개)]`;
        setList.appendChild(spTitle);
        Object.keys(SPECIAL_SETS).forEach(setName => {
            setList.appendChild(makeSetButton(setName, char));
        });

        document.getElementById("panel").innerHTML = "";
    }

    // ===== 세트 버튼 생성 =====
    function makeSetButton(setName, char) {
        let count3 = 0, count5 = 0;
        let totalParts = 0; // x 값 (총 개수) 초기화

        const slots = ALL_SETS[setName] || [];
        const prefixes = ALL_PREFIX[setName] || [];
        const setType = getSetType(setName);
        const exceedSlots = EXCEED_SLOTS[setType] || [];

        // 1. 전체 고유 부위 개수 계산 (접두어/익시드 무시)
        const distinctParts = getCachedDistinctParts(char, setName);

        const allGroupKeys = [];

        // 레거시 세트는 일반 행 없음
        if (!LEGACY_PREFIX_SETS.includes(setName)) {
            allGroupKeys.push(setName);
        }

        prefixes.forEach(pref => {
            const prefKey = makePrefixKey(pref, setName);
            allGroupKeys.push(prefKey);
            EXCEED_TAGS.forEach(tag => {
                allGroupKeys.push(`[${tag}] ${prefKey}`);
            });
        });

        allGroupKeys.forEach(groupKey => {
            const isExceedKey = groupKey.startsWith('[');
            slots.forEach(slot => {
                let key = `${groupKey} ${slot}`;
                if (isExceedKey && !exceedSlots.includes(slot)) return;
                totalParts += char.armorCounts[key] || 0;
            });
        });
        // 총합 계산 끝

        // 3. 단일 distinctParts를 사용한 최종 세트 판정
        const fullSize = slots.length;

        if (fullSize === 5) { // 방어구
            if (distinctParts === fullSize) count5 = 1; // 5세트 달성
            else if (distinctParts >= 3) count3 = 1; // 3세트 달성 (3 또는 4)
        } else { // 악세/특장 (3부위)
            if (distinctParts === 3) count3 = 1; // 3세트 달성
        }

        const btn = document.createElement("button");
        btn.className = "set-btn";

        // 화면 표시를 위한 0 또는 1 값 설정
        const final_count3 = count3 > 0 ? 1 : 0;
        const final_count5 = count5 > 0 ? 1 : 0;

        // 배경색 적용
        if (final_count5 > 0) btn.classList.add("set5");
        else if (final_count3 > 0) btn.classList.add("set3");

        // [선택 상태 유지 로직 추가]: 현재 선택된 세트와 이름이 같으면 selected 클래스 유지
        if (currentSetName === setName && currentChar && currentChar.id === char.id) {
            btn.classList.add("selected");
        }

        // 🚨 수정된 부분: "세트명 (장비수)" 형태로 내용 구성
        let buttonContent = `${setName} (${totalParts})`;

        // ✅ 추가: 악세/특장 추가 정보 표시
        if (setType === "ACCESSORY" && ACCESSORY_EXTRA_INFO[setName]) {
            buttonContent += `<br>(${ACCESSORY_EXTRA_INFO[setName]})</span>`;
        } else if (setType === "SPECIAL" && SPECIAL_EXTRA_INFO[setName]) {
            buttonContent += `<br>(${SPECIAL_EXTRA_INFO[setName]})</span>`;
        }

        btn.innerHTML = buttonContent; // innerHTML로 내용 설정

        btn.onclick = (event) => {
            // [선택 로직 추가]: 모든 세트 버튼에서 'selected' 클래스 제거
            document.querySelectorAll(".set-btn").forEach(b => b.classList.remove("selected"));
            // [선택 로직 추가]: 현재 클릭된 버튼에 'selected' 클래스 추가
            event.currentTarget.classList.add("selected");

            openSet(setName, char);
        };

        return btn;
    }

    // ===== 세트 표 열기 =====
    function openSet(setName, char) {
        if (currentSetName !== setName || currentChar?.id !== char.id) {
            currentFilter = 'ALL';
        }

        currentSetName = setName;
        currentChar = char;

        // ✅ 세트 열 때 해당 캐릭터의 캐시 미리 계산
        getCachedDistinctParts(char, setName);

        const panel = document.getElementById("panel");
        panel.innerHTML = `<h2>[${setName} 세트]</h2>`;

        const slots = ALL_SETS[setName] || [];
        const setType = getSetType(setName);
        const table = document.createElement("table");

        if (setType === "SPECIAL") {
            // ====================================================
            // 특장 전용: 표 2개로 나누어 렌더링
            // 표1(위): 귀걸이(두 번째 이름)+나머지슬롯 - 일반/프리픽스 행
            // 표2(아래): 귀걸이(첫 번째 이름)만 - 익시드+프리픽스 행
            // ====================================================
            const displayNames = SPECIAL_DISPLAY_NAMES[setName] || null;
            const prefixes = ALL_PREFIX[setName] || [];
            const exceedSlot = EXCEED_SLOTS["SPECIAL"][0];
            const earringRaw = displayNames ? (displayNames[exceedSlot] || exceedSlot) : exceedSlot;
            const earringName1 = Array.isArray(earringRaw) ? earringRaw[0] : earringRaw;
            const earringName2 = Array.isArray(earringRaw) ? earringRaw[1] : earringRaw;

            // ── 표 1 (위): 일반/프리픽스 (귀걸이 두 번째 이름 + 나머지 슬롯) ──
            const table1 = document.createElement("table");
            const otherSlots = slots.filter(s => s !== exceedSlot);
            const allSlots1 = [exceedSlot, ...otherSlots];

            const headerSlots1 = allSlots1.map(s => {
                let displayName;
                if (s === exceedSlot) {
                    displayName = earringName2; // 베키의 문양 귀걸이
                } else {
                    displayName = displayNames ? (displayNames[s] || s) : s;
                }
                return `<th style="white-space:nowrap; font-size:0.9em; padding:8px;">${displayName}</th>`;
            }).join("");
            table1.innerHTML = `<thead><tr>
  <th style="white-space:nowrap; padding:8px;">세트 이름</th>
  ${headerSlots1}
</tr></thead><tbody></tbody>`;
            const tbody1 = table1.querySelector("tbody");

            tbody1.appendChild(createEquipmentRow({
                char: char,
                setName: setName,
                nameKey: setName,
                labelText: "일반",
                slots: allSlots1,
                fullSize: 3
            }));

            prefixes.forEach(pref => {
                const styledPref = `<span style="color:#e6b800; font-weight:bold;">${pref}</span>`;
                tbody1.appendChild(createEquipmentRow({
                    char: char,
                    setName: setName,
                    nameKey: `${pref}: ${setName}`,
                    labelText: styledPref,
                    slots: allSlots1,
                    fullSize: 3
                }));
            });

            // ── 표 2 (아래): exceed 전용 (귀걸이 첫 번째 이름만) ──
            const table2 = document.createElement("table");
            table2.innerHTML = `<thead><tr>
  <th style="white-space:nowrap; padding:8px;">세트 이름</th>
  <th style="white-space:nowrap; font-size:0.9em; padding:8px;">${earringName1}</th>
</tr></thead><tbody></tbody>`;
            const tbody2 = table2.querySelector("tbody");

            prefixes.forEach(pref => {
                EXCEED_TAGS.forEach(ex => {
                    const name = `[${ex}] ${pref}: ${setName}`;
                    const key = `${name} ${exceedSlot}`;
                    const val = char.armorCounts[key] || 0;
                    const color = EXCEED_COLOR_MAP[ex] || "#fff";
                    const labelHtml = `<span style="color:${color}; font-weight:bold;">[${ex}]</span> ${pref}`;
                    const tr = document.createElement("tr");
                    tr.innerHTML = `<td style="text-align:center;">${labelHtml}</td><td>${makeNumberButton(char.id, key, val)}</td>`;
                    tbody2.appendChild(tr);
                });
            });

            panel.appendChild(table1);
            panel.appendChild(document.createElement("br"));
            panel.appendChild(table2);

            // 표1(위) 너비: 일반/접두어 행 이름 기준
            const normalNames = ["일반", ...prefixes];
            const w1 = calcNameWidth(normalNames);
            table1.querySelectorAll("th:first-child, td:first-child").forEach(cell => {
                cell.style.width = w1 + "px";
            });

            // 표2(아래) 너비: 익시드 행 이름 기준
            const exceedNames = prefixes.flatMap(p => EXCEED_TAGS.map(ex => `[${ex}] ${p}`));
            const w2 = calcNameWidth(exceedNames.length ? exceedNames : ["일반"]);
            table2.querySelectorAll("th:first-child, td:first-child").forEach(cell => {
                cell.style.width = w2 + "px";
            });

        } else if (setType === "ACCESSORY" && ACCESSORY_DISPLAY_NAMES[setName]) {
            // ====================================================
            // 악세 전용: 표 2개로 나누어 렌더링 (특장과 동일한 방식)
            // 표1(위): 일반/프리픽스 - 팔찌 두번째 이름 + 목걸이 + 반지
            // 표2(아래): 익시드 전용 - 팔찌 첫번째 이름만
            // ====================================================
            const displayNames = ACCESSORY_DISPLAY_NAMES[setName];
            const prefixes = ALL_PREFIX[setName] || [];
            const exceedSlot = EXCEED_SLOTS["ACCESSORY"][0];
            const braceletRaw = displayNames[exceedSlot] || exceedSlot;
            const braceletName1 = Array.isArray(braceletRaw) ? braceletRaw[0] : braceletRaw;
            const braceletName2 = Array.isArray(braceletRaw) ? braceletRaw[1] : braceletRaw;

            // ── 표1(위): 일반/프리픽스 (팔찌 두번째 + 목걸이 + 반지) ──
            const accTable1 = document.createElement("table");
            const otherSlots = slots.filter(s => s !== exceedSlot);
            const allSlots1 = [exceedSlot, ...otherSlots];

            const headerSlots1 = allSlots1.map(s => {
                let displayName;
                if (s === exceedSlot) {
                    displayName = braceletName2;
                } else {
                    displayName = displayNames[s] || s;
                }
                return `<th style="white-space:nowrap; font-size:0.9em; padding:8px;">${displayName}</th>`;
            }).join("");
            accTable1.innerHTML = `<thead><tr>
  <th style="white-space:nowrap; padding:8px;">세트 이름</th>
  ${headerSlots1}
</tr></thead><tbody></tbody>`;
            const tbody1 = accTable1.querySelector("tbody");

            // ★ 레거시 악세: 일반 행 없음, 접두어("레거시") 행만
            if (!LEGACY_PREFIX_SETS.includes(setName)) {
                tbody1.appendChild(createEquipmentRow({
                    char: char,
                    setName: setName,
                    nameKey: setName,
                    labelText: "일반",
                    slots: allSlots1,
                    fullSize: 3
                }));
            }
            prefixes.forEach(pref => {
                const styledPref = `<span style="color:#e6b800; font-weight:bold;">${pref}</span>`;
                const prefKey = makePrefixKey(pref, setName);
                tbody1.appendChild(createEquipmentRow({
                    char: char,
                    setName: setName,
                    nameKey: prefKey,
                    labelText: styledPref,
                    slots: allSlots1,
                    fullSize: 3
                }));
            });

            const accTable2 = document.createElement("table");
            accTable2.innerHTML = `<thead><tr>
  <th style="white-space:nowrap; padding:8px;">세트 이름</th>
  <th style="white-space:nowrap; font-size:0.9em; padding:8px;">${braceletName1}</th>
</tr></thead><tbody></tbody>`;
            const tbody2 = accTable2.querySelector("tbody");

            if (prefixes.length > 0) {
                prefixes.forEach(pref => {
                    EXCEED_TAGS.forEach(ex => {
                        const prefKey = makePrefixKey(pref, setName);
                        const name = `[${ex}] ${prefKey}`;
                        const key = `${name} ${exceedSlot}`;
                        const val = char.armorCounts[key] || 0;
                        const color = EXCEED_COLOR_MAP[ex] || "#fff";
                        const labelHtml = `<span style="color:${color}; font-weight:bold;">[${ex}]</span> <span style="color:#e6b800; font-weight:bold;">${pref}</span>`;
                        const tr = document.createElement("tr");
                        tr.innerHTML = `<td style="text-align:center;">${labelHtml}</td><td>${makeNumberButton(char.id, key, val)}</td>`;
                        tbody2.appendChild(tr);
                    });
                });
            }

            panel.appendChild(accTable1);
            panel.appendChild(document.createElement("br"));
            panel.appendChild(accTable2);

            const accNormalNames = LEGACY_PREFIX_SETS.includes(setName) ? [...prefixes] : ["일반", ...prefixes];
            const accW1 = calcNameWidth(accNormalNames.length ? accNormalNames : ["일반"]);
            accTable1.querySelectorAll("th:first-child, td:first-child").forEach(cell => {
                cell.style.width = accW1 + "px";
            });

            const accExceedNames = prefixes.flatMap(p => EXCEED_TAGS.map(ex => `[${ex}] ${p}`));
            const accW2 = calcNameWidth(accExceedNames.length ? accExceedNames : ["일반"]);
            accTable2.querySelectorAll("th:first-child, td:first-child").forEach(cell => {
                cell.style.width = accW2 + "px";
            });

        } else if (setType === "ARMOR" && ARMOR_DISPLAY_NAMES[setName]) {
            // ====================================================
            // 방어구 전용: 표 2개로 나누어 렌더링
            // 표1(위): 일반/프리픽스 - 상의 두번째 이름 + 나머지 슬롯
            // 표2(아래): 익시드 전용 - 상의 첫번째 이름만
            // ====================================================
            const displayNames = ARMOR_DISPLAY_NAMES[setName];
            const prefixes = ALL_PREFIX[setName] || [];
            const exceedSlot = EXCEED_SLOTS["ARMOR"][0];
            const topRaw = displayNames[exceedSlot] || exceedSlot;
            const topName1 = Array.isArray(topRaw) ? topRaw[0] : topRaw;
            const topName2 = Array.isArray(topRaw) ? topRaw[1] : topRaw;

            // ── 표1(위): 익시드 전용 (상의 첫번째 이름만) ──
            const armTable1 = document.createElement("table");
            armTable1.innerHTML = `<thead><tr>
  <th style="white-space:nowrap; padding:8px;">세트 이름</th>
  <th style="white-space:nowrap; font-size:0.9em; padding:8px;">${topName1}</th>
</tr></thead><tbody></tbody>`;
            const tbody1 = armTable1.querySelector("tbody");

            if (prefixes.length > 0) {
                prefixes.forEach(pref => {
                    EXCEED_TAGS.forEach(ex => {
                        const prefKey = makePrefixKey(pref, setName);
                        const name = `[${ex}] ${prefKey}`;
                        const key = `${name} ${exceedSlot}`;
                        const val = char.armorCounts[key] || 0;
                        const color = EXCEED_COLOR_MAP[ex] || "#fff";
                        const labelHtml = `<span style="color:${color}; font-weight:bold;">[${ex}]</span> <span style="color:#e6b800; font-weight:bold;">${pref}</span>`;
                        const tr = document.createElement("tr");
                        tr.innerHTML = `<td style="text-align:center;">${labelHtml}</td><td>${makeNumberButton(char.id, key, val)}</td>`;
                        tbody1.appendChild(tr);
                    });
                });
            }

            // ── 표2(아래): 일반/접두어 ──
            const armTable2 = document.createElement("table");
            const otherSlots = slots.filter(s => s !== exceedSlot);
            const allSlots2 = [exceedSlot, ...otherSlots];

            const headerSlots2 = allSlots2.map(s => {
                let displayName;
                if (s === exceedSlot) {
                    displayName = topName2;
                } else {
                    displayName = displayNames[s] || s;
                }
                return `<th style="white-space:nowrap; font-size:0.9em; padding:8px;">${displayName}</th>`;
            }).join("");
            armTable2.innerHTML = `<thead><tr>
  <th style="white-space:nowrap; padding:8px;">세트 이름</th>
  ${headerSlots2}
</tr></thead><tbody></tbody>`;
            const tbody2 = armTable2.querySelector("tbody");

            // ★ 레거시 방어구: 일반 행 없음, 접두어("레거시") 행만
            if (!LEGACY_PREFIX_SETS.includes(setName)) {
                tbody2.appendChild(createEquipmentRow({
                    char: char,
                    setName: setName,
                    nameKey: setName,
                    labelText: "일반",
                    slots: allSlots2,
                    fullSize: slots.length
                }));
            }
            prefixes.forEach(pref => {
                const styledPref = `<span style="color:#e6b800; font-weight:bold;">${pref}</span>`;
                const prefKey = makePrefixKey(pref, setName);
                tbody2.appendChild(createEquipmentRow({
                    char: char,
                    setName: setName,
                    nameKey: prefKey,
                    labelText: styledPref,
                    slots: allSlots2,
                    fullSize: slots.length
                }));
            });

            panel.appendChild(armTable2);
            panel.appendChild(document.createElement("br"));
            panel.appendChild(armTable1);

            const armNormalNames = LEGACY_PREFIX_SETS.includes(setName) ? [...prefixes] : ["일반", ...prefixes];
            const armW1 = calcNameWidth(armNormalNames.length ? armNormalNames : ["일반"]);
            armTable2.querySelectorAll("th:first-child, td:first-child").forEach(cell => {
                cell.style.width = armW1 + "px";
            });

            const armExceedNames = prefixes.flatMap(p => EXCEED_TAGS.map(ex => `[${ex}] ${p}`));
            const armW2 = calcNameWidth(armExceedNames.length ? armExceedNames : ["일반"]);
            armTable1.querySelectorAll("th:first-child, td:first-child").forEach(cell => {
                cell.style.width = armW2 + "px";
            });

        } else {
            // 방어구 기존 로직 (ARMOR_DISPLAY_NAMES 없는 경우)
            const headerSlots = slots.map(s => {
                return `<th style="max-width:150px; white-space:normal; font-size:0.9em; line-height:1.3; padding:8px;">${s}</th>`;
            }).join("");
            table.innerHTML = `<thead><tr>
  <th style="max-width:200px; white-space:normal;">세트 이름</th>
  ${headerSlots}
</tr></thead><tbody></tbody>`;
            const tbody = table.querySelector("tbody");

            if (!LEGACY_PREFIX_SETS.includes(setName)) {
                tbody.appendChild(makeRow(setName, setName, char));
            }
            const prefixes = ALL_PREFIX[setName] || [];
            prefixes.forEach(pref => {
                const prefKey = makePrefixKey(pref, setName);
                tbody.appendChild(makeRow(prefKey, setName, char));
            });
            prefixes.forEach(pref => {
                EXCEED_TAGS.forEach(ex => {
                    const prefKey = makePrefixKey(pref, setName);
                    tbody.appendChild(makeRow(`[${ex}] ${prefKey}`, setName, char));
                });
            });

            panel.appendChild(table);

            table.querySelectorAll("th:first-child, td:first-child").forEach(cell => {
                cell.style.width = globalSetNameWidth + "px";
            });
            table.querySelectorAll("th:not(:first-child), td:not(:first-child)").forEach(cell => {
                cell.style.width = globalSlotWidth + "px";
            });
        }
    }

    // ─────────────────────────────────────────
    // 9.2 테이블 행 생성
    // ─────────────────────────────────────────
    function makeRow(name, setName, char) {
        const slots = ALL_SETS[setName] || [];
        const groupKey = getGroupKey(name);
        const isExceed = isExceedName(name);
        const setType = getSetType(setName);
        const exceedSlots = EXCEED_SLOTS[setType];

        const totalDistinct = getCachedDistinctParts(char, setName);
        const fullSize = slots.length;

        const tr = document.createElement("tr");
        let hasAnyPartInRow = false;

        slots.forEach(slot => {
            let key = `${name} ${slot}`;
            if ((char.armorCounts[key] || 0) > 0) {
                hasAnyPartInRow = true;
            }
        });

        if (hasAnyPartInRow) {
            if (setType === "ARMOR") {
                if (totalDistinct === fullSize) tr.className = "set5";
                else if (totalDistinct >= 3) tr.className = "set3";
            } else {
                if (totalDistinct === 3) tr.className = "set3";
            }
        }

        let itemName = name;
        let finalHtmlName = itemName;

        const exceedMatch = itemName.match(/^(\[.*?\])\s*(.*)/);
        let exceedTagHtml = '';
        let nameWithoutTag = itemName;

        if (exceedMatch) {
            const tag = exceedMatch[1];
            nameWithoutTag = exceedMatch[2];
            const color = getExceedColor(tag);
            exceedTagHtml = `<span style="color:${color}; font-weight:bold;">${tag}</span> `;
        }

        let baseNameHtml = nameWithoutTag;
        const prefixMatch = nameWithoutTag.match(/(.+?):\s*(.+)/);

        if (prefixMatch) {
            const prefix = prefixMatch[1];
            const baseSet = prefixMatch[2];
            const styledPrefix = `<span style="color:#e6b800; font-weight:bold;">${prefix}</span>`;
            baseNameHtml = `${styledPrefix}: ${baseSet}`;
        }

        finalHtmlName = exceedTagHtml + baseNameHtml;

        let html = `<td style="text-align:left;">${finalHtmlName}</td>`;

        slots.forEach(slot => {
            let key = `${name} ${slot}`;
            const val = char.armorCounts[key] || 0;
            if (isExceed) {
                if (exceedSlots.includes(slot)) {
                    html += `<td>${makeNumberButton(char.id, key, val)}</td>`;
                } else {
                    html += `<td></td>`;
                }
            } else {
                html += `<td>${makeNumberButton(char.id, key, val)}</td>`;
            }
        });
        tr.innerHTML = html;
        return tr;
    }

    // 7-3. 장비 증감
    // ===== 숫자 버튼 (우클릭 감소 기능 포함) =====
    function makeNumberButton(charId, key, val) {
        const extraClass = val > 0 ? " positive" : "";
        return `<button class="num-btn${extraClass}"
      oncontextmenu="decrement('${charId}','${key}'); return false;"
      onclick="increment('${charId}','${key}')">${val}</button>`;
    }

    // ─────────────────────────────────────────
    // 9.4 UI 업데이트 (Step 1 최적화)
    // ─────────────────────────────────────────
    function updateEquipmentButton(charId, key, newValue) {
        // ✅ 1단계: 테이블에서 모든 버튼 검색
        const tables = document.querySelectorAll("#panel table");
        if (!tables || tables.length === 0) return;

        let buttonFound = false;

        // ✅ 2단계: 모든 테이블 순회 (익시드는 별도 테이블)
        tables.forEach(table => {
            const buttons = table.querySelectorAll('.num-btn');
            buttons.forEach(btn => {
                const onclickStr = btn.getAttribute('onclick') || '';
                const oncontextmenuStr = btn.getAttribute('oncontextmenu') || '';

                // ✅ 3단계: onclick 또는 oncontextmenu에서 매치 확인
                const matchInClick = onclickStr.includes(`'${charId}'`) && onclickStr.includes(`'${key}'`);
                const matchInContext = oncontextmenuStr.includes(`'${charId}'`) && oncontextmenuStr.includes(`'${key}'`);

                if (matchInClick || matchInContext) {
                    buttonFound = true;

                    // 버튼 업데이트
                    btn.textContent = newValue;
                    if (newValue > 0) {
                        btn.classList.add('positive');
                    } else {
                        btn.classList.remove('positive');
                    }

                    // 행 색상 업데이트
                    const row = btn.closest('tr');
                    if (row && currentSetName && currentChar) {
                        updateRowColor(row, currentChar, currentSetName);
                    }
                }
            });
        });

        // ✅ 4단계: 디버깅 (개발자 도구에서 확인용, 나중에 제거 가능)
        if (!buttonFound) {
            console.log('버튼을 찾지 못했습니다:', key);
        }
    }

    // 테이블 행의 세트 색상 업데이트
    function updateRowColor(row, char, setName) {
        const totalDistinct = getCachedDistinctParts(char, setName);
        const setType = getSetType(setName);
        const slots = ALL_SETS[setName] || [];
        const fullSize = slots.length;

        // 기존 색상 제거
        row.classList.remove('set3', 'set5');

        const firstCell = row.querySelector('td');
        if (!firstCell) return;

        const rowText = firstCell.textContent || firstCell.innerText;

        // 행 이름에서 그룹키 추출
        let rowGroupKey = '';

        // 익시드 + 접두어
        const exceedMatch = rowText.match(/\[(선봉|의지|이상)\]/);
        const prefixMatch = rowText.match(/(전격|허상|작열|침식|수호|왜곡|자상|맹독|보호|쇄도|신속|연격|레거시|견고|혈독|초석|각오|가속|조화|불굴|숙련|결의|격변|촉진|질주)/);

        if (rowText.includes('일반')) {
            // 일반 행
            rowGroupKey = setName;
        } else if (exceedMatch && prefixMatch) {
            // 익시드 행: [선봉] 전격
            const tag = exceedMatch[1];
            const prefix = prefixMatch[1];
            const prefKey = makePrefixKey(prefix, setName);
            rowGroupKey = `[${tag}] ${prefKey}`;
        } else if (prefixMatch) {
            // 접두어 행: 전격
            const prefix = prefixMatch[1];
            rowGroupKey = makePrefixKey(prefix, setName);
        }

        if (!rowGroupKey) return;

        // ✅ 이 행이 실제로 데이터를 가지고 있는지 확인
        let hasAnyPartInRow = false;
        const exceedSlots = EXCEED_SLOTS[setType] || [];
        const isExceedRow = rowGroupKey.startsWith('[');

        slots.forEach(slot => {
            // 익시드 행은 특정 슬롯만 체크
            if (isExceedRow && !exceedSlots.includes(slot)) return;

            const key = `${rowGroupKey} ${slot}`;
            if ((char.armorCounts[key] || 0) > 0) {
                hasAnyPartInRow = true;
            }
        });

        // ✅ 이 행에 데이터가 있으면 전체 세트 기준으로 색상 적용
        if (hasAnyPartInRow) {
            if (setType === "ARMOR") {
                if (totalDistinct === fullSize) {
                    row.classList.add('set5');
                } else if (totalDistinct >= 3) {
                    row.classList.add('set3');
                }
            } else {
                if (totalDistinct === 3) {
                    row.classList.add('set3');
                }
            }
        }
    }

    // 테이블의 모든 행 색상을 업데이트 (세트 효과 변경 시)
    function updateAllRowColors(char, setName) {
        // ✅ 모든 테이블 선택 (일반/접두어 + 익시드)
        const tables = document.querySelectorAll("#panel table");
        if (!tables || tables.length === 0) return;

        // ✅ 각 테이블의 모든 행 업데이트
        tables.forEach(table => {
            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => {
                updateRowColor(row, char, setName);
            });
        });
    }

    // 세트 버튼의 개수만 업데이트 (재렌더링 없이)
    function updateSetButtonCount(setName, char) {
        const setButtons = document.querySelectorAll('.set-btn');
        setButtons.forEach(btn => {
            const btnText = btn.textContent || btn.innerText;
            if (!btnText.includes(setName)) return;

            const slots = ALL_SETS[setName] || [];
            const prefixes = ALL_PREFIX[setName] || [];
            const setType = getSetType(setName);
            const exceedSlots = EXCEED_SLOTS[setType] || [];

            const allGroupKeys = [];
            if (!LEGACY_PREFIX_SETS.includes(setName)) {
                allGroupKeys.push(setName);
            }
            prefixes.forEach(pref => {
                const prefKey = makePrefixKey(pref, setName);
                allGroupKeys.push(prefKey);
                EXCEED_TAGS.forEach(tag => {
                    allGroupKeys.push(`[${tag}] ${prefKey}`);
                });
            });

            let totalParts = 0;
            allGroupKeys.forEach(groupKey => {
                const isExceedKey = groupKey.startsWith('[');
                slots.forEach(slot => {
                    if (isExceedKey && !exceedSlots.includes(slot)) return;
                    const key = `${groupKey} ${slot}`;
                    totalParts += char.armorCounts[key] || 0;
                });
            });

            const newText = btnText.replace(/\(\d+\)/, `(${totalParts})`);
            btn.innerHTML = btn.innerHTML.replace(btnText, newText);

            const distinctParts = getCachedDistinctParts(char, setName);
            const fullSize = slots.length;

            btn.classList.remove('set3', 'set5');
            if (fullSize === 5) {
                if (distinctParts === fullSize) btn.classList.add('set5');
                else if (distinctParts >= 3) btn.classList.add('set3');
            } else {
                if (distinctParts === 3) btn.classList.add('set3');
            }
        });
    }

    // 카테고리별 총 개수 업데이트 (방어구, 악세, 특장)
    function updateCategoryTotals(char) {
        const setList = document.getElementById("setList");
        if (!setList) return;

        // 1. 방어구 총 개수
        let totalArmor = 0;
        Object.keys(ARMOR_SETS).forEach(setName => {
            const slots = ARMOR_SETS[setName];
            const prefixes = ARMOR_PREFIX[setName] || [];

            if (!LEGACY_PREFIX_SETS.includes(setName)) {
                slots.forEach(slot => {
                    totalArmor += char.armorCounts[`${setName} ${slot}`] || 0;
                });
            }

            prefixes.forEach(pref => {
                const prefKey = makePrefixKey(pref, setName);
                slots.forEach(slot => {
                    totalArmor += char.armorCounts[`${prefKey} ${slot}`] || 0;
                });

                EXCEED_TAGS.forEach(tag => {
                    slots.forEach(slot => {
                        totalArmor += char.armorCounts[`[${tag}] ${prefKey} ${slot}`] || 0;
                    });
                });
            });
        });

        // 2. 악세 총 개수
        let totalAccessory = 0;
        Object.keys(ACCESSORY_SETS).forEach(setName => {
            const slots = ACCESSORY_SETS[setName];
            const prefixes = ACCESSORY_PREFIX[setName] || [];

            if (!LEGACY_PREFIX_SETS.includes(setName)) {
                slots.forEach(slot => {
                    totalAccessory += char.armorCounts[`${setName} ${slot}`] || 0;
                });
            }

            prefixes.forEach(pref => {
                const prefKey = makePrefixKey(pref, setName);
                slots.forEach(slot => {
                    totalAccessory += char.armorCounts[`${prefKey} ${slot}`] || 0;
                });

                EXCEED_TAGS.forEach(tag => {
                    slots.forEach(slot => {
                        totalAccessory += char.armorCounts[`[${tag}] ${prefKey} ${slot}`] || 0;
                    });
                });
            });
        });

        // 3. 특장 총 개수
        let totalSpecial = 0;
        Object.keys(SPECIAL_SETS).forEach(setName => {
            const slots = SPECIAL_SETS[setName];
            const prefixes = SPECIAL_PREFIX[setName] || [];

            slots.forEach(slot => {
                totalSpecial += char.armorCounts[`${setName} ${slot}`] || 0;
            });

            prefixes.forEach(pref => {
                const prefKey = makePrefixKey(pref, setName);
                slots.forEach(slot => {
                    totalSpecial += char.armorCounts[`${prefKey} ${slot}`] || 0;
                });

                EXCEED_TAGS.forEach(tag => {
                    slots.forEach(slot => {
                        totalSpecial += char.armorCounts[`[${tag}] ${prefKey} ${slot}`] || 0;
                    });
                });
            });
        });

        // 4. 헤더 텍스트 업데이트
        const headers = setList.querySelectorAll('h2');
        headers.forEach(header => {
            const text = header.textContent;
            if (text.includes('방어구')) {
                header.textContent = `[방어구 (${totalArmor}개)]`;
            } else if (text.includes('악세')) {
                header.textContent = `[악세 (${totalAccessory}개)]`;
            } else if (text.includes('특장')) {
                header.textContent = `[특장 (${totalSpecial}개)]`;
            }
        });
    }

    // ─────────────────────────────────────────
    // 9.3 장비 개수 증감
    // ─────────────────────────────────────────
    function increment(charId, key) {
        const char = characters.find(c => c.id === charId);
        const oldValue = char.armorCounts[key] || 0;
        const newValue = oldValue + 1;

        char.armorCounts[key] = newValue;
        char.updateTimes[key] = Date.now();
        saveLocalData();

        // ✅ 캐시 무효화 (데이터 변경되었으므로)
        if (currentSetName) {
            invalidateDistinctCache(charId, currentSetName);
        }

        updateEquipmentButton(charId, key, newValue);
        if (currentSetName) {
            updateSetButtonCount(currentSetName, char);
            updateAllRowColors(char, currentSetName);
        }
        updateCategoryTotals(char);
    }

    // 🚨 감소 함수 (우클릭 시 호출)
    function decrement(charId, key) {
        const char = characters.find(c => c.id === charId);
        const cur = char.armorCounts[key] || 0;
        const newValue = Math.max(0, cur - 1);

        char.armorCounts[key] = newValue;
        char.updateTimes[key] = Date.now();
        saveLocalData();

        // ✅ 캐시 무효화
        if (currentSetName) {
            invalidateDistinctCache(charId, currentSetName);
        }

        updateEquipmentButton(charId, key, newValue);
        if (currentSetName) {
            updateSetButtonCount(currentSetName, char);
            updateAllRowColors(char, currentSetName);
        }
        updateCategoryTotals(char);
    }

    // ─────────────────────────────────────────
    // 9.5 장비 관리 탭
    // ─────────────────────────────────────────
    function renderEquipmentTab(mode) {
        // ✅ 상태 초기화
        isCharacterEquipmentViewOpen = false;
        isStatisticsViewOpen = false;
        selectedCharacterForEquipment = null;

        // ✅ 모든 영역 초기화
        document.getElementById("character-selection-area").style.display = "none";
        document.getElementById("character-equipment-detail").style.display = "none";
        document.getElementById("equipment-display-area").style.display = "block";

        const displayArea = document.getElementById("equipment-display-area");
        const CATEGORIES = [
            {name: "방어구", sets: ARMOR_SETS, prefix: ARMOR_PREFIX, id: 'cat-armor'},
            {name: "악세", sets: ACCESSORY_SETS, prefix: ACCESSORY_PREFIX, id: 'cat-accessory'},
            {name: "특장", sets: SPECIAL_SETS, prefix: SPECIAL_PREFIX, id: 'cat-special'}
        ];

        // 스크롤 버튼 추가
        let scrollButtonHtml = `<div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">`;
        CATEGORIES.forEach(cat => {
            scrollButtonHtml += `<button class="char-btn" style="background: #4a33cc; border: 1px solid #ffd700;"
                            onclick="scrollToCategory('${cat.id}')">${cat.name}로 이동 →</button>`;
        });
        scrollButtonHtml += `</div>`;

        let fullHtml = scrollButtonHtml + `<h2 style="color:#ffd700; margin-bottom:20px;">📊 캐릭터별 상세 현황 (${mode})</h2>`;

        CATEGORIES.forEach(cat => {
            fullHtml += `<div id="${cat.id}" style="margin-bottom: 50px; padding-top: 20px; border-top: 3px solid #4a33cc;">`;
            fullHtml += `<h2 style="color:#ffd700; font-size: 24px; margin-bottom: 15px;">🔹 ${cat.name}</h2>`;

            Object.keys(cat.sets).forEach(baseSetName => {
                const prefixes = cat.prefix[baseSetName] || [];
                const slots = cat.sets[baseSetName];
                const setType = getSetType(baseSetName);
                let targetGroupKeys = [];

                // NORMAL: 레거시 세트는 일반 행 없음
                if ((mode === 'NORMAL' || mode === 'ALL') && !LEGACY_PREFIX_SETS.includes(baseSetName)) {
                    targetGroupKeys.push({
                        full: baseSetName,
                        display: "일반",
                        type: 'NORMAL'
                    });
                }

                if (mode === 'PREFIX' || mode === 'ALL') {
                    prefixes.forEach(p => {
                        const prefKey = makePrefixKey(p, baseSetName);
                        targetGroupKeys.push({
                            full: prefKey,
                            display: p,
                            type: 'PREFIX'
                        });
                    });
                }

                if (mode === 'EXCEED' || mode === 'ALL') {
                    if (prefixes.length > 0) {
                        prefixes.forEach(p => {
                            const prefKey = makePrefixKey(p, baseSetName);
                            EXCEED_TAGS.forEach(tag => targetGroupKeys.push({
                                full: `[${tag}] ${prefKey}`,
                                display: p,
                                tag: tag,
                                type: 'EXCEED'
                            }));
                        });
                    }
                }

                if (targetGroupKeys.length === 0) return;

                fullHtml += `<h3 style="color:#fff; margin-top:30px;">[${baseSetName} 세트]</h3>`;

                let displaySlots = slots;
                if (mode === 'EXCEED') {
                    if (setType === "ARMOR") displaySlots = ["상의"];
                    else if (setType === "ACCESSORY") displaySlots = ["팔찌"];
                    else if (setType === "SPECIAL") displaySlots = ["귀걸이"];
                }

                fullHtml += `<table style="width:max-content; border-collapse:collapse; margin-bottom:20px; border:1px solid #2a3158;">
    <thead style="background:#181c33;"><tr>
        <th style="padding:10px; border:1px solid #2a3158; white-space:nowrap;">직업</th>
        <th style="padding:10px; border:1px solid #2a3158; white-space:nowrap;">이름</th>
        ${(mode === 'ALL' || mode === 'EXCEED') ? '<th style="padding:10px; border:1px solid #2a3158; white-space:nowrap;">익시드</th>' : ''}
        ${mode !== 'NORMAL' ? '<th style="padding:10px; border:1px solid #2a3158; white-space:nowrap;">접두어</th>' : ''}
        ${displaySlots.map(s => {
                    const rawName = (setType === "SPECIAL" && SPECIAL_DISPLAY_NAMES[baseSetName] && SPECIAL_DISPLAY_NAMES[baseSetName][s])
                        ? SPECIAL_DISPLAY_NAMES[baseSetName][s]
                        : (setType === "ACCESSORY" && ACCESSORY_DISPLAY_NAMES[baseSetName] && ACCESSORY_DISPLAY_NAMES[baseSetName][s])
                            ? ACCESSORY_DISPLAY_NAMES[baseSetName][s]
                            : (setType === "ARMOR" && ARMOR_DISPLAY_NAMES[baseSetName] && ARMOR_DISPLAY_NAMES[baseSetName][s])
                                ? ARMOR_DISPLAY_NAMES[baseSetName][s]
                                : s;
                    let displayName;
                    if (Array.isArray(rawName)) {
                        // 익시드 모드: [0](익시드), 일반/접두어 모드: [1](일반), ALL: 둘 다 표시
                        if (mode === 'EXCEED') displayName = rawName[0];
                        else if (mode === 'ALL') displayName = rawName[0] + "<br>" + rawName[1];
                        else displayName = rawName[1];
                    } else {
                        displayName = rawName;
                    }
                    const thWrap = (Array.isArray(rawName) && mode === 'ALL') ? "normal" : "nowrap";
                    return `<th style="padding:10px; border:1px solid #2a3158; white-space:${thWrap}; font-size:0.85em; line-height:1.2;">${displayName}</th>`;
                }).join('')}
        ${mode !== 'EXCEED' ? '<th style="padding:10px; border:1px solid #2a3158; white-space:nowrap;">달성</th>' : ''}
    </tr></thead><tbody>`;

                characters.forEach(char => {
                    const totalDistinct = calcTotalDistinctParts(char, baseSetName);

                    // 해당 캐릭터가 가진 현재 세트의 아이템 데이터 그룹들
                    const charGroups = targetGroupKeys.filter(group =>
                        slots.some(s => (char.armorCounts?.[`${group.full} ${s}`] || 0) > 0)
                    );

                    charGroups.forEach((group, gIdx) => {
                        // 각 모드별로 달성도 계산
                        let displayDistinct = totalDistinct;
                        let statusColor = "#fff";

                        if (mode === 'NORMAL') {
                            displayDistinct = 0;
                            slots.forEach(slot => {
                                const key = `${baseSetName} ${slot}`;
                                if ((char.armorCounts[key] || 0) > 0) displayDistinct++;
                            });
                        } else if (mode === 'PREFIX') {
                            displayDistinct = 0;
                            slots.forEach(slot => {
                                const key = `${group.full} ${slot}`;
                                if ((char.armorCounts[key] || 0) > 0) displayDistinct++;
                            });
                        }

                        // 색상 결정
                        if (setType === "ARMOR") {
                            if (displayDistinct === 5) statusColor = "#ffd700";
                            else if (displayDistinct >= 3) statusColor = "#2ecc71";
                        } else {
                            if (displayDistinct === 3) statusColor = "#2ecc71";
                        }

                        let slotsHtml = displaySlots.map(s => {
                            const count = char.armorCounts?.[`${group.full} ${s}`] || 0;
                            return `<td style="padding:10px; border:1px solid #2a3158; text-align:center; color:${count > 0 ? '#fff' : '#444'}; font-weight:bold;">${count}</td>`;
                        }).join('');

                        let rowInfo = "";
                        const tagColor = EXCEED_COLOR_MAP[group.tag] || "#ffd700";

                        // 💡 일반 모드가 아닐 때만 접두어(display) 셀을 생성
                        if (mode === 'ALL' || mode === 'EXCEED') {
                            const tagCol = group.tag ? `<td style="padding:10px; border:1px solid #2a3158; color:${tagColor}; font-weight:bold; white-space:nowrap;">[${group.tag}]</td>` : `<td style="border:1px solid #2a3158;"></td>`;
                            rowInfo = tagCol + `<td style="padding:10px; border:1px solid #2a3158; color:#ffd700; font-weight:bold; white-space:nowrap;">${group.display}</td>`;
                        } else if (mode === 'PREFIX') {
                            rowInfo = `<td style="padding:10px; border:1px solid #2a3158; color:#ffd700; font-weight:bold; white-space:nowrap;">${group.display}</td>`;
                        }

                        // 💡 [모두] 버튼일 때만 캐릭터 경계선에 진한 선 적용
                        const isLastRowOfChar = (gIdx === charGroups.length - 1);
                        const borderStyle = (mode === 'ALL' && isLastRowOfChar) ? "border-bottom: 3px solid #666;" : "border-bottom: 1px solid #2a3158;";

                        fullHtml += `<tr>
                    <td style="padding:10px; ${borderStyle} background:#181c33; white-space:nowrap;">${char.job}</td>
                    <td style="padding:10px; ${borderStyle} white-space:nowrap;">${char.name}</td>
                    ${rowInfo.replace(/border:1px solid #2a3158/g, borderStyle)}${slotsHtml.replace(/border:1px solid #2a3158/g, borderStyle)}
                    ${mode !== 'EXCEED' ? `<td style="padding:10px; ${borderStyle} font-weight:bold; text-align:center; color:${statusColor};">${displayDistinct}</td>` : ''}
                </tr>`;
                    });
                });
                fullHtml += `</tbody></table>`;
            });

            fullHtml += `</div>`; // 카테고리 닫는 태그 추가
        });

        displayArea.innerHTML = fullHtml;
    }

    // 2. 전체 현황 렌더링 (이름 열 너비 고정 및 색상 적용)
    function renderFullEquipmentTab(mode) {
        // ✅ 상태 초기화
        isCharacterEquipmentViewOpen = false;
        isStatisticsViewOpen = false;
        selectedCharacterForEquipment = null;

        // ✅ 모든 영역 초기화
        document.getElementById("character-selection-area").style.display = "none";
        document.getElementById("character-equipment-detail").style.display = "none";
        document.getElementById("equipment-display-area").style.display = "block";

        const displayArea = document.getElementById("equipment-display-area");
        const CATEGORIES = [
            {name: "방어구", sets: ARMOR_SETS, prefix: ARMOR_PREFIX, id: 'cat-armor'},
            {name: "악세", sets: ACCESSORY_SETS, prefix: ACCESSORY_PREFIX, id: 'cat-accessory'},
            {name: "특장", sets: SPECIAL_SETS, prefix: SPECIAL_PREFIX, id: 'cat-special'}
        ];

        // 스크롤 버튼 추가
        let scrollButtonHtml = `<div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">`;
        CATEGORIES.forEach(cat => {
            scrollButtonHtml += `<button class="char-btn" style="background: #4a33cc; border: 1px solid #ffd700;"
                            onclick="scrollToCategory('${cat.id}')">${cat.name}로 이동 →</button>`;
        });
        scrollButtonHtml += `</div>`;

        let fullHtml = scrollButtonHtml + `<h2 style="color:#ffd700; margin-bottom:20px;">🌎 아이템별 전체 현황 (${mode})</h2>`;

        CATEGORIES.forEach(cat => {
            fullHtml += `<div id="${cat.id}" style="margin-bottom: 50px; padding-top: 20px; border-top: 3px solid #4a33cc;">`;
            fullHtml += `<h2 style="color:#ffd700; font-size: 24px; margin-bottom: 15px;">🔹 ${cat.name}</h2>`;

            Object.keys(cat.sets).forEach(baseSetName => {
                const prefixes = cat.prefix[baseSetName] || [];
                let slots = [...cat.sets[baseSetName]];
                let targetGroups = [];

                if (mode === 'NORMAL' && !LEGACY_PREFIX_SETS.includes(baseSetName)) {
                    targetGroups.push({display: baseSetName, full: baseSetName, type: 'NORMAL'});
                } else if (mode === 'PREFIX') {
                    prefixes.forEach(p => {
                        const prefKey = makePrefixKey(p, baseSetName);
                        targetGroups.push({
                            display: p,
                            full: prefKey,
                            type: 'PREFIX'
                        });
                    });
                } else if (mode === 'EXCEED') {
                    slots = slots.filter(s => s === "상의" || s === "팔찌" || s === "귀걸이");
                    if (slots.length === 0) return;

                    // 💡 기존 로직 (접두어 있는 익시드)
                    if (prefixes.length > 0) {
                        prefixes.forEach(p => {
                            const prefKey = makePrefixKey(p, baseSetName);
                            EXCEED_TAGS.forEach(tag => targetGroups.push({
                                display: p,
                                full: prefKey,
                                tag: tag,
                                type: 'EXCEED'
                            }));
                        });
                    }
                }

                if (targetGroups.length === 0) return;

                // 해당 세트 데이터 존재 여부 확인
                const hasData = targetGroups.some(group => {
                    const searchKeyBase = group.tag ? `[${group.tag}] ${group.full}` : group.full;
                    return characters.some(c => slots.some(slot => (c.armorCounts?.[`${searchKeyBase} ${slot}`] || 0) > 0));
                });
                if (!hasData) return;

                fullHtml += `<h3 style="color:#fff; margin-top:30px; margin-bottom:10px;">[${baseSetName} 세트]</h3>`;

                // renderFullEquipmentTab() 함수 내부
                fullHtml += `<table style="width: max-content; border-collapse: collapse; margin-bottom: 20px; border: 1px solid #2a3158;">
    <thead style="background:#181c33;"><tr>
        <th style="padding:10px; border:1px solid #2a3158; color:#fff; text-align:center; white-space:nowrap;">아이템 세트 이름</th>
        ${slots.map(s => {
                    // ✅ 표시용 이름 적용
                    const setType = getSetType(baseSetName);
                    const rawName = (setType === "SPECIAL" && SPECIAL_DISPLAY_NAMES[baseSetName] && SPECIAL_DISPLAY_NAMES[baseSetName][s])
                        ? SPECIAL_DISPLAY_NAMES[baseSetName][s]
                        : (setType === "ACCESSORY" && ACCESSORY_DISPLAY_NAMES[baseSetName] && ACCESSORY_DISPLAY_NAMES[baseSetName][s])
                            ? ACCESSORY_DISPLAY_NAMES[baseSetName][s]
                            : (setType === "ARMOR" && ARMOR_DISPLAY_NAMES[baseSetName] && ARMOR_DISPLAY_NAMES[baseSetName][s])
                                ? ARMOR_DISPLAY_NAMES[baseSetName][s]
                                : s;
                    let displayName;
                    if (Array.isArray(rawName)) {
                        // 익시드 모드: [0](익시드), 일반/접두어 모드: [1](일반)
                        displayName = (mode === 'EXCEED') ? rawName[0] : rawName[1];
                    } else {
                        displayName = rawName;
                    }
                    return `<th style="padding:10px; border:1px solid #2a3158; color:#fff; text-align:center; white-space:nowrap; min-width:180px; max-width:200px; font-size:0.85em; line-height:1.2;">${displayName}</th>`;
                }).join('')}
    </tr></thead><tbody>`;

                targetGroups.forEach(group => {
                    const searchKeyBase = group.tag ? `[${group.tag}] ${group.full}` : group.full;

                    // 💡 접두어 장비일 때만 모든 슬롯 보유 여부를 체크
                    const isFullPrefixSet = (group.type === 'PREFIX') && slots.every(slot =>
                        characters.some(c => (c.armorCounts?.[`${searchKeyBase} ${slot}`] || 0) > 0)
                    );

                    const rowBg = isFullPrefixSet ? "#5c4d00" : "#0f1222";
                    const labelBg = isFullPrefixSet ? "#7a6700" : "#111529";

                    let relevantOwners = characters.filter(c => {
                        return slots.some(slot => (c.armorCounts?.[`${searchKeyBase} ${slot}`] || 0) > 0);
                    });

                    let displayName = "";
                    if (group.type === 'EXCEED' || group.type === 'PREFIX') {
                        // 레거시 세트: baseSetName이 이미 "레거시: 마력의 소용돌이" 형태
                        // group.full도 "레거시: 마력의 소용돌이"이므로 중복 방지
                        if (LEGACY_PREFIX_SETS.includes(baseSetName)) {
                            // baseSetName에서 "레거시: " 부분 제거
                            const pureSetName = baseSetName.replace(/^레거시:\s*/, '');
                            displayName = `<span style="color:#ffd700; font-weight:bold;">레거시</span>: <span style="color:#fff;">${pureSetName}</span>`;
                        } else {
                            displayName = `<span style="color:#ffd700; font-weight:bold;">${group.display}</span>: <span style="color:#fff;">${baseSetName}</span>`;
                        }
                        if (group.tag) {
                            const tagColor = EXCEED_COLOR_MAP[group.tag] || "#ffd700";
                            displayName = `<span style="color:${tagColor}; font-weight:bold;">[${group.tag}]</span> ` + displayName;
                        }
                    } else {
                        displayName = `<span style="color:#fff;">${group.full}</span>`;
                    }

                    fullHtml += `<tr style="background: ${rowBg};">
                <td style="padding:12px; border:1px solid #2a3158; background:${labelBg}; vertical-align:middle; text-align:center; white-space:nowrap; color:#fff; font-size:14px;">${displayName}</td>`;

                    slots.forEach(slot => {
                        fullHtml += `<td style="padding:8px; border:1px solid #2a3158; vertical-align:middle; text-align:center;">`;

                        if (mode === 'EXCEED') {
                            // 💡 익시드: 가로줄 맞추지 않고 데이터가 있는 캐릭터만 촘촘하게 출력
                            const ownersWithItem = characters.filter(c => (c.armorCounts?.[`${searchKeyBase} ${slot}`] || 0) > 0);
                            if (ownersWithItem.length > 0) {
                                ownersWithItem.forEach(owner => {
                                    const count = owner.armorCounts[`${searchKeyBase} ${slot}`];
                                    fullHtml += `<div style="margin:4px 0; white-space:nowrap; font-size:14px;">
                                    <span style="color:#aaa;">${owner.job}</span>
                                    <span style="color:#fff; font-weight:bold;">(${owner.name})</span>
                                    <span style="color:#ffd700; font-weight:bold;">[${count}]</span>
                                </div>`;
                                });
                            } else {
                                fullHtml += `<span style="color:#444;">0</span>`;
                            }
                        } else {
                            // 💡 일반/접두어: 모든 캐릭터의 자리를 만들어 가로줄 라인을 맞춤 (30px 고정)
                            relevantOwners.forEach(owner => {
                                const count = owner.armorCounts?.[`${searchKeyBase} ${slot}`] || 0;
                                fullHtml += `<div style="height:30px; border-bottom:1px solid rgba(255,255,255,0.05); display:flex; justify-content:center; align-items:center; gap:8px; white-space:nowrap; padding: 0 10px; font-size:14px;">`;
                                if (count > 0) {
                                    fullHtml += `<span style="color:#aaa;">${owner.job}</span>
                                             <span style="color:#fff; font-weight:bold;">(${owner.name})</span>
                                             <span style="color:#ffd700; font-weight:bold;">[${count}]</span>`;
                                } else {
                                    fullHtml += `<span style="color:#444;">0</span>`;
                                }
                                fullHtml += `</div>`;
                            });
                        }
                        fullHtml += `</td>`;
                    });
                    fullHtml += `</tr>`;
                });
                fullHtml += `</tbody></table>`;
            });
            fullHtml += `</div>`; // 카테고리 닫는 태그 추가
        });

        displayArea.innerHTML = fullHtml;
    }

    // 장비 관리 버튼 활성화 로직 (무기 관리 방식 참조)
    function setActiveEquipmentButton(clickedBtn) {
        // 1. 장비 관리 섹션(#section-equipment-view) 전체에서 모든 char-btn을 찾음
        const allEquipmentButtons = document.querySelectorAll("#section-equipment-view .char-btn");

        // 2. 모든 버튼에서 active 클래스 제거 (불빛 끄기)
        allEquipmentButtons.forEach(btn => btn.classList.remove('active'));

        // 3. 현재 클릭한 버튼에만 active 클래스 추가 (불빛 켜기)
        if (clickedBtn) {
            clickedBtn.classList.add('active');
        }
    }

    function scrollToCategory(categoryId) {
        const element = document.getElementById(categoryId);
        if (element) {
            element.scrollIntoView({ behavior: 'smooth' });
        }
    }

    /* ========================================
   7-5. 캐릭터별 장비 보유 현황
   ======================================== */
    let isCharacterEquipmentViewOpen = false;
    let selectedCharacterForEquipment = null;
    let isStatisticsViewOpen = false;  // 통계 화면 상태 추가

    // 캐릭터별 장비 보유 현황 토글
    function toggleCharacterEquipmentView() {
        const selectionArea = document.getElementById("character-selection-area");
        const detailArea = document.getElementById("character-equipment-detail");
        const displayArea = document.getElementById("equipment-display-area");

        // ✅ 통계 화면 닫기
        isStatisticsViewOpen = false;

        // 토글
        isCharacterEquipmentViewOpen = !isCharacterEquipmentViewOpen;

        if (isCharacterEquipmentViewOpen) {
            // 열기
            displayArea.style.display = "none";
            selectionArea.style.display = "block";
            detailArea.style.display = "none";

            // 캐릭터 버튼 렌더링
            renderCharacterButtons();

            // ✅ 모든 장비 관리 버튼 비활성화
            document.querySelectorAll("#section-equipment-view .equipment-button-row .char-btn").forEach(btn => {
                btn.classList.remove('active');
            });
        } else {
            // 닫기
            selectionArea.style.display = "none";
            detailArea.style.display = "none";
            displayArea.style.display = "block";

            // 기본 화면으로 복귀
            renderEquipmentTab('ALL');

            // ✅ 첫 번째 버튼(모두) 활성화
            const firstBtn = document.querySelector("#section-equipment-view .equipment-button-row .char-btn");
            if (firstBtn) {
                firstBtn.classList.add('active');
            }
        }
    }

    // 캐릭터 버튼 렌더링
    function renderCharacterButtons() {
        const buttonArea = document.getElementById("character-buttons-area");
        buttonArea.innerHTML = "";

        characters.forEach(char => {
            const btn = document.createElement("button");
            btn.className = "char-btn";
            btn.textContent = `${char.job} (${char.name})`;
            btn.style.minWidth = "150px";

            if (selectedCharacterForEquipment === char.id) {
                btn.classList.add("active");
            }

            btn.onclick = () => {
                selectedCharacterForEquipment = char.id;
                renderCharacterButtons(); // 버튼 활성화 상태 갱신
                renderCharacterEquipmentDetail(char);
            };

            buttonArea.appendChild(btn);
        });
    }

    // 캐릭터 장비 상세 현황 렌더링
    function renderCharacterEquipmentDetail(char) {
        const detailArea = document.getElementById("character-equipment-detail");
        detailArea.style.display = "block";

        let html = `<h2 style="color: #ffd700; margin-bottom: 20px;">${char.job} (${char.name}) - 장비 보유 현황</h2>`;

        const CATEGORIES = [
            {
                title: "방어구",
                sets: ARMOR_SETS,
                prefix: ARMOR_PREFIX,
                exceedOnly: [],
                exceedSlot: "상의"
            },
            {
                title: "악세",
                sets: ACCESSORY_SETS,
                prefix: ACCESSORY_PREFIX,
                exceedOnly: [],
                exceedSlot: "팔찌"
            },
            {
                title: "특장",
                sets: SPECIAL_SETS,
                prefix: SPECIAL_PREFIX,
                exceedOnly: [],
                exceedSlot: "귀걸이"
            }
        ];

        CATEGORIES.forEach(category => {
            // ✅ 카테고리별 총 개수 계산
            let categoryTotal = 0;
            Object.keys(category.sets).forEach(baseSetName => {
                const setSlots = category.sets[baseSetName];
                const prefixes = category.prefix[baseSetName] || [];
                const isLegacy = LEGACY_PREFIX_SETS.includes(baseSetName);

                // 일반 장비 개수 (레거시는 없음)
                if (!isLegacy) {
                    setSlots.forEach(slot => {
                        const normalKey = `${baseSetName} ${slot}`;
                        categoryTotal += char.armorCounts[normalKey] || 0;
                    });
                }

                // 접두어 장비 개수
                prefixes.forEach(pref => {
                    const prefKey = makePrefixKey(pref, baseSetName);
                    setSlots.forEach(slot => {
                        categoryTotal += char.armorCounts[`${prefKey} ${slot}`] || 0;
                    });
                });

                // 익시드 장비 개수
                EXCEED_TAGS.forEach(tag => {
                    prefixes.forEach(pref => {
                        const prefKey = makePrefixKey(pref, baseSetName);
                        setSlots.forEach(slot => {
                            const exceedKey = `[${tag}] ${prefKey} ${slot}`;
                            categoryTotal += char.armorCounts[exceedKey] || 0;
                        });
                    });
                });
            });

            // ✅ 제목에 총 개수 표시
            html += `<h2 style="color: #ffd700; margin-bottom: 15px;">🔹 ${category.title} <span style="color: #ffd700; font-weight: bold;">(${categoryTotal}개)</span></h2>`;

            html += `<table style="width: max-content; border-collapse: collapse; margin-bottom: 30px;">`;

            // 헤더
            const slots = Object.values(category.sets)[0] || [];
            // renderCharacterEquipmentDetail() 함수 내부
            html += `<thead style="background: #181c33;"><tr>
    <th style="padding: 10px; border: 1px solid #2a3158; white-space: nowrap; text-align: center;">세트</th>
    <th style="padding: 10px; border: 1px solid #2a3158; white-space: nowrap;">익시드</th>
    <th style="padding: 10px; border: 1px solid #2a3158; white-space: nowrap;">접두어</th>`;

            slots.forEach(slot => {
                html += `<th style="padding: 10px; border: 1px solid #2a3158; white-space: normal; max-width: 120px; font-size: 0.85em; line-height: 1.2;">${slot}</th>`;
            });

            html += `</tr></thead><tbody>`;

            // 각 세트별 데이터
            Object.keys(category.sets).forEach(baseSetName => {
                const setSlots = category.sets[baseSetName];
                const prefixes = category.prefix[baseSetName] || [];
                const exceedSlot = category.exceedSlot;
                const isLegacy = LEGACY_PREFIX_SETS.includes(baseSetName);

                // 세트별 데이터 수집
                let rows = [];

                // 1. 익시드 행들
                prefixes.forEach(pref => {
                    EXCEED_TAGS.forEach(tag => {
                        let rowData = {
                            type: 'exceed',
                            exceed: tag,
                            prefix: pref,
                            slots: {}
                        };

                        setSlots.forEach(slot => {
                            const prefKey = makePrefixKey(pref, baseSetName);
                            const key = `[${tag}] ${prefKey} ${slot}`;
                            rowData.slots[slot] = char.armorCounts[key] || 0;
                        });

                        if (Object.values(rowData.slots).some(v => v > 0)) {
                            rows.push(rowData);
                        }
                    });
                });

                // 2. 접두어 행들
                prefixes.forEach(pref => {
                    let rowData = {
                        type: 'prefix',
                        exceed: '',
                        prefix: pref,
                        slots: {}
                    };

                    setSlots.forEach(slot => {
                        const prefKey = makePrefixKey(pref, baseSetName);
                        const key = `${prefKey} ${slot}`;
                        rowData.slots[slot] = char.armorCounts[key] || 0;
                    });

                    // 데이터가 있는 경우만 추가
                    if (Object.values(rowData.slots).some(v => v > 0)) {
                        rows.push(rowData);
                    }
                });

                // 3. 일반 행 (레거시 세트는 없음)
                if (!isLegacy) {
                    let normalRowData = {
                        type: 'normal',
                        exceed: '',
                        prefix: '',
                        slots: {}
                    };

                    setSlots.forEach(slot => {
                        const key = `${baseSetName} ${slot}`;
                        normalRowData.slots[slot] = char.armorCounts[key] || 0;
                    });

                    if (Object.values(normalRowData.slots).some(v => v > 0)) {
                        rows.push(normalRowData);
                    }
                }

                // 행이 하나도 없으면 이 세트는 건너뜀
                if (rows.length === 0) return;

                // 테이블 행 렌더링
                rows.forEach((row, rowIdx) => {
                    html += `<tr style="border-bottom: 1px solid #444;">`;

                    // 세트명 (첫 행에만 rowspan으로 표시)
                    if (rowIdx === 0) {
                        html += `<td rowspan="${rows.length}" style="padding: 10px; border: 1px solid #2a3158; font-weight: bold; background: #1a1e33; text-align: center; vertical-align: middle; white-space: nowrap;">${baseSetName}</td>`;
                    }

                    // 익시드 열
                    if (row.exceed) {
                        const tagColor = EXCEED_COLOR_MAP[row.exceed] || "#ffd700";
                        html += `<td style="padding: 10px; border: 1px solid #2a3158; text-align: center; white-space: nowrap;">
                        <span style="color: ${tagColor}; font-weight: bold;">[${row.exceed}]</span>
                    </td>`;
                    } else {
                        html += `<td style="padding: 10px; border: 1px solid #2a3158; text-align: center;"></td>`;
                    }

                    // 접두어 열
                    if (row.prefix) {
                        html += `<td style="padding: 10px; border: 1px solid #2a3158; text-align: center; white-space: nowrap;">
                        <span style="color: #e6b800; font-weight: bold;">${row.prefix}</span>
                    </td>`;
                    } else {
                        html += `<td style="padding: 10px; border: 1px solid #2a3158; text-align: center;"></td>`;
                    }

                    // 각 슬롯별 개수
                    setSlots.forEach(slot => {
                        const count = row.slots[slot] || 0;

                        // 익시드 행인데 익시드 슬롯이 아니면 빈칸
                        if (row.type === 'exceed' && slot !== exceedSlot) {
                            html += `<td style="padding: 10px; border: 1px solid #2a3158; text-align: center; background: #0a0c15;"></td>`;
                        } else {
                            const displayCount = count > 0 ? count : "";
                            html += `<td style="padding: 10px; border: 1px solid #2a3158; text-align: center; color: #fff; font-weight: bold;">${displayCount}</td>`;
                        }
                    });

                    html += `</tr>`;
                });

                // 세트 구분선 (두꺼운 선)
                html += `<tr style="height: 3px; background: #2a3158;"><td colspan="${3 + setSlots.length}" style="padding: 0; border: none;"></td></tr>`;
            });

            html += `</tbody></table>`;
        });

        // ✅ 무기 섹션 추가
        if (char.weaponCounts && Object.keys(char.weaponCounts).length > 0) {
            // 무기 총 개수 계산
            let totalWeapons = 0;
            Object.values(char.weaponCounts).forEach(count => {
                totalWeapons += count || 0;
            });

            html += `<h2 style="color: #ffd700; margin-top: 40px; margin-bottom: 15px;">🔹 무기 <span style="color: #ffd700; font-weight: bold;">(${totalWeapons}개)</span></h2>`;

            // 직업별로 무기 분류
            JOB_LIST.forEach(jobName => {
                const jobWeaponData = WEAPON_DATA_MAP[jobName];
                if (!jobWeaponData) return;

                // 해당 직업의 무기를 보유하고 있는지 확인
                let hasWeaponsForJob = false;
                const weaponRows = [];

                Object.entries(jobWeaponData).forEach(([category, weaponList]) => {
                    let categoryWeapons = [];

                    weaponList.forEach(weaponName => {
                        WEAPON_PREFIXES.forEach(prefix => {
                            const weaponKey = `${prefix.tag} ${weaponName}`;
                            const count = char.weaponCounts[weaponKey] || 0;

                            if (count > 0) {
                                hasWeaponsForJob = true;
                                categoryWeapons.push({name: weaponName, prefix: prefix, count: count});
                            }
                        });
                    });

                    if (categoryWeapons.length > 0) {
                        weaponRows.push({category: category, weapons: categoryWeapons});
                    }
                });

                if (!hasWeaponsForJob) return;

                html += `<h4 style="color: #fff; margin-top: 25px; margin-bottom: 10px;">[${jobName}]</h4>`;

                html += `<table style="width: max-content; border-collapse: collapse; margin-bottom: 20px;">`;
                html += `<thead style="background: #181c33;"><tr>
                <th style="padding: 10px; border: 1px solid #2a3158; white-space: nowrap; text-align: center; width: 100px;">종류</th>
                <th style="padding: 10px; border: 1px solid #2a3158; white-space: nowrap; text-align: left;">무기 이름</th>
                <th style="padding: 10px; border: 1px solid #2a3158; white-space: nowrap; text-align: center; width: 80px;">개수</th>
            </tr></thead><tbody>`;

                weaponRows.forEach(row => {
                    row.weapons.forEach((weapon, idx) => {
                        html += `<tr style="border-bottom: 1px solid #444;">`;

                        // 종류 (첫 무기에만 rowspan)
                        if (idx === 0) {
                            html += `<td rowspan="${row.weapons.length}" style="padding: 10px; border: 1px solid #2a3158; font-weight: bold; background: #1a1e33; text-align: center; vertical-align: middle;">${row.category}</td>`;
                        }

                        // 무기 이름 (접두어 색상 적용)
                        html += `<td style="padding: 10px; border: 1px solid #2a3158; text-align: left;">
                        <span style="color: ${weapon.prefix.color}; font-weight: bold;">${weapon.prefix.tag}</span> ${weapon.name}
                    </td>`;

                        // 개수
                        html += `<td style="padding: 10px; border: 1px solid #2a3158; text-align: center; color: #fff; font-weight: bold;">${weapon.count}</td>`;

                        html += `</tr>`;
                    });

                    // 종류 구분선
                    html += `<tr style="height: 3px; background: #2a3158;"><td colspan="3" style="padding: 0; border: none;"></td></tr>`;
                });

                html += `</tbody></table>`;
            });
        }

        detailArea.innerHTML = html;
    }

    // 장비 통계 표시 함수
    function showEquipmentStatistics() {
        // ✅ 상태 업데이트
        isCharacterEquipmentViewOpen = false;
        isStatisticsViewOpen = true;
        selectedCharacterForEquipment = null;

        // 기존 화면 숨기기
        document.getElementById("character-selection-area").style.display = "none";
        document.getElementById("character-equipment-detail").style.display = "none";

        const displayArea = document.getElementById("equipment-display-area");
        displayArea.style.display = "block";

        // ✅ 모든 장비 관리 버튼 비활성화
        document.querySelectorAll("#section-equipment-view .equipment-button-row .char-btn").forEach(btn => {
            btn.classList.remove('active');
        });

        let html = `<h2 style="color: #ffd700; margin-bottom: 20px;">📊 캐릭터별 장비 보유 통계</h2>`;

        // 통계 테이블
        html += `<table style="width: max-content; border-collapse: collapse; margin-bottom: 30px;">`;
        html += `<thead style="background: #181c33;"><tr>
        <th style="padding: 10px; border: 1px solid #2a3158; white-space: nowrap; text-align: center;">직업(이름)</th>
        <th style="padding: 10px; border: 1px solid #2a3158; white-space: nowrap; text-align: center;">방어구</th>
        <th style="padding: 10px; border: 1px solid #2a3158; white-space: nowrap; text-align: center;">악세</th>
        <th style="padding: 10px; border: 1px solid #2a3158; white-space: nowrap; text-align: center;">특장</th>
        <th style="padding: 10px; border: 1px solid #2a3158; white-space: nowrap; text-align: center;">무기</th>
        <th style="padding: 10px; border: 1px solid #2a3158; white-space: nowrap; text-align: center;">합계</th>
    </tr></thead><tbody>`;

        // 각 캐릭터별 통계
        characters.forEach(char => {
            let armorCount = 0;
            let accessoryCount = 0;
            let specialCount = 0;
            let weaponCount = 0;

            // 방어구/악세/특장 개수 계산
            if (char.armorCounts) {
                Object.entries(char.armorCounts).forEach(([key, count]) => {
                    if (count <= 0) return;

                    const parts = key.split(' ');
                    const slot = parts.pop();
                    const name = parts.join(' ');
                    const groupKey = getGroupKey(name);
                    const setType = getSetType(groupKey);

                    if (setType === "ARMOR") armorCount += count;
                    else if (setType === "ACCESSORY") accessoryCount += count;
                    else if (setType === "SPECIAL") specialCount += count;
                });
            }

            // 무기 개수 계산
            if (char.weaponCounts) {
                Object.values(char.weaponCounts).forEach(count => {
                    weaponCount += count || 0;
                });
            }

            const total = armorCount + accessoryCount + specialCount + weaponCount;

            html += `<tr style="border-bottom: 1px solid #444;">
            <td style="padding: 10px; border: 1px solid #2a3158; text-align: center; font-weight: bold;">${char.job}(${char.name})</td>
            <td style="padding: 10px; border: 1px solid #2a3158; text-align: center; color: #fff; font-weight: bold;">${armorCount}</td>
            <td style="padding: 10px; border: 1px solid #2a3158; text-align: center; color: #fff; font-weight: bold;">${accessoryCount}</td>
            <td style="padding: 10px; border: 1px solid #2a3158; text-align: center; color: #fff; font-weight: bold;">${specialCount}</td>
            <td style="padding: 10px; border: 1px solid #2a3158; text-align: center; color: #fff; font-weight: bold;">${weaponCount}</td>
            <td style="padding: 10px; border: 1px solid #2a3158; text-align: center; color: #ffd700; font-weight: bold;">${total}</td>
        </tr>`;
        });

        // 전체 합계 행
        let totalArmor = 0;
        let totalAccessory = 0;
        let totalSpecial = 0;
        let totalWeapon = 0;

        characters.forEach(char => {
            if (char.armorCounts) {
                Object.entries(char.armorCounts).forEach(([key, count]) => {
                    if (count <= 0) return;
                    const parts = key.split(' ');
                    const slot = parts.pop();
                    const name = parts.join(' ');
                    const groupKey = getGroupKey(name);
                    const setType = getSetType(groupKey);

                    if (setType === "ARMOR") totalArmor += count;
                    else if (setType === "ACCESSORY") totalAccessory += count;
                    else if (setType === "SPECIAL") totalSpecial += count;
                });
            }

            if (char.weaponCounts) {
                Object.values(char.weaponCounts).forEach(count => {
                    totalWeapon += count || 0;
                });
            }
        });

        const grandTotal = totalArmor + totalAccessory + totalSpecial + totalWeapon;

        html += `<tr style="background: #1a1e33; border-top: 3px solid #ffd700;">
        <td style="padding: 10px; border: 1px solid #2a3158; text-align: center; font-weight: bold; color: #ffd700;">전체 합계</td>
        <td style="padding: 10px; border: 1px solid #2a3158; text-align: center; color: #ffd700; font-weight: bold;">${totalArmor}</td>
        <td style="padding: 10px; border: 1px solid #2a3158; text-align: center; color: #ffd700; font-weight: bold;">${totalAccessory}</td>
        <td style="padding: 10px; border: 1px solid #2a3158; text-align: center; color: #ffd700; font-weight: bold;">${totalSpecial}</td>
        <td style="padding: 10px; border: 1px solid #2a3158; text-align: center; color: #ffd700; font-weight: bold;">${totalWeapon}</td>
        <td style="padding: 10px; border: 1px solid #2a3158; text-align: center; color: #ffd700; font-weight: bold; font-size: 1.1em;">${grandTotal}</td>
    </tr>`;

        html += `</tbody></table>`;

        displayArea.innerHTML = html;
    }

    /* ========================================
   7-6. 장비 검색 기능
   ======================================== */
    function searchEquipment() {
        const searchInput = document.getElementById("equipment-search-input");
        const searchTerm = searchInput.value.trim();

        if (!searchTerm) {
            alert("검색어를 입력해주세요!");
            return;
        }

        // ✅ 상태 업데이트
        isCharacterEquipmentViewOpen = false;
        isStatisticsViewOpen = false;
        selectedCharacterForEquipment = null;

        // 기존 화면 숨기기
        document.getElementById("character-selection-area").style.display = "none";
        document.getElementById("character-equipment-detail").style.display = "none";

        const displayArea = document.getElementById("equipment-display-area");
        displayArea.style.display = "block";

        // ✅ 모든 장비 관리 버튼 비활성화
        document.querySelectorAll("#section-equipment-view .equipment-button-row .char-btn").forEach(btn => {
            btn.classList.remove('active');
        });

        let html = `<h2 style="color: #ffd700; margin-bottom: 20px;">🔍 검색 결과: "${searchTerm}"</h2>`;

        const CATEGORIES = [
            {name: "방어구", sets: ARMOR_SETS, prefix: ARMOR_PREFIX},
            {name: "악세", sets: ACCESSORY_SETS, prefix: ACCESSORY_PREFIX},
            {name: "특장", sets: SPECIAL_SETS, prefix: SPECIAL_PREFIX}
        ];

        let foundSets = [];

        // 검색어와 일치하는 세트 찾기
        CATEGORIES.forEach(category => {
            Object.keys(category.sets).forEach(baseSetName => {
                if (baseSetName.includes(searchTerm)) {
                    foundSets.push({
                        category: category.name,
                        setName: baseSetName,
                        slots: category.sets[baseSetName],
                        prefixes: category.prefix[baseSetName] || [],
                        isLegacy: LEGACY_PREFIX_SETS.includes(baseSetName)
                    });
                }
            });
        });

        if (foundSets.length === 0) {
            html += `<p style="color: #888; font-size: 1.2em; margin-top: 50px; text-align: center;">검색 결과가 없습니다.</p>`;
            displayArea.innerHTML = html;
            return;
        }

        // 검색 결과 표시
        foundSets.forEach(set => {
            html += `<h3 style="color: #fff; margin-top: 30px; margin-bottom: 15px;">[${set.category}] ${set.setName}</h3>`;

            html += `<table style="width: max-content; border-collapse: collapse; margin-bottom: 30px; border: 1px solid #2a3158;">`;
            html += `<thead style="background: #181c33;"><tr>
            <th style="padding: 10px; border: 1px solid #2a3158; white-space: nowrap;">직업(이름)</th>
            <th style="padding: 10px; border: 1px solid #2a3158; white-space: nowrap;">익시드</th>
            <th style="padding: 10px; border: 1px solid #2a3158; white-space: nowrap;">접두어</th>`;

            set.slots.forEach(slot => {
                html += `<th style="padding: 10px; border: 1px solid #2a3158; white-space: normal; max-width: 120px; font-size: 0.85em; line-height: 1.2;">${slot}</th>`;
            });

            html += `<th style="padding: 10px; border: 1px solid #2a3158; white-space: nowrap;">합계</th>`;
            html += `</tr></thead><tbody>`;

            // 캐릭터별 데이터 수집
            characters.forEach(char => {
                let charRows = [];

                // 익시드 데이터
                if (set.prefixes.length > 0) {
                    set.prefixes.forEach(pref => {
                        EXCEED_TAGS.forEach(tag => {
                            let rowData = {type: 'exceed', exceed: tag, prefix: pref, slots: {}, total: 0};
                            const prefKey = makePrefixKey(pref, set.setName);
                            set.slots.forEach(slot => {
                                const key = `[${tag}] ${prefKey} ${slot}`;
                                const count = char.armorCounts?.[key] || 0;
                                rowData.slots[slot] = count;
                                rowData.total += count;
                            });
                            if (rowData.total > 0) charRows.push(rowData);
                        });
                    });
                }

                // 접두어 데이터
                set.prefixes.forEach(pref => {
                    let rowData = {type: 'prefix', exceed: '', prefix: pref, slots: {}, total: 0};
                    const prefKey = makePrefixKey(pref, set.setName);
                    set.slots.forEach(slot => {
                        const key = `${prefKey} ${slot}`;
                        const count = char.armorCounts?.[key] || 0;
                        rowData.slots[slot] = count;
                        rowData.total += count;
                    });

                    if (rowData.total > 0) charRows.push(rowData);
                });

                // 일반 데이터 (레거시 세트는 건너뜀)
                if (!set.isLegacy) {
                    let normalRow = {type: 'normal', exceed: '', prefix: '', slots: {}, total: 0};
                    set.slots.forEach(slot => {
                        const key = `${set.setName} ${slot}`;
                        const count = char.armorCounts?.[key] || 0;
                        normalRow.slots[slot] = count;
                        normalRow.total += count;
                    });
                    if (normalRow.total > 0) charRows.push(normalRow);
                }

                // 행이 없으면 이 캐릭터는 건너뜀
                if (charRows.length === 0) return;

                // 테이블 행 렌더링
                charRows.forEach((row, rowIdx) => {
                    html += `<tr style="border-bottom: 1px solid #444;">`;

                    // 캐릭터 이름 (첫 행에만 rowspan)
                    if (rowIdx === 0) {
                        html += `<td rowspan="${charRows.length}" style="padding: 10px; border: 1px solid #2a3158; font-weight: bold; background: #1a1e33; text-align: center; vertical-align: middle; white-space: nowrap;">${char.job}(${char.name})</td>`;
                    }

                    // 익시드 열
                    if (row.exceed) {
                        const tagColor = EXCEED_COLOR_MAP[row.exceed] || "#ffd700";
                        html += `<td style="padding: 10px; border: 1px solid #2a3158; text-align: center; white-space: nowrap;">
                        <span style="color: ${tagColor}; font-weight: bold;">[${row.exceed}]</span>
                    </td>`;
                    } else {
                        html += `<td style="padding: 10px; border: 1px solid #2a3158;"></td>`;
                    }

                    // 접두어 열
                    if (row.prefix) {
                        html += `<td style="padding: 10px; border: 1px solid #2a3158; text-align: center; white-space: nowrap;">
                        <span style="color: #e6b800; font-weight: bold;">${row.prefix}</span>
                    </td>`;
                    } else {
                        html += `<td style="padding: 10px; border: 1px solid #2a3158;"></td>`;
                    }

                    // 슬롯별 개수
                    set.slots.forEach(slot => {
                        const count = row.slots[slot] || 0;
                        const displayCount = count > 0 ? count : "";
                        html += `<td style="padding: 10px; border: 1px solid #2a3158; text-align: center; color: #fff; font-weight: bold;">${displayCount}</td>`;
                    });

                    // 합계
                    html += `<td style="padding: 10px; border: 1px solid #2a3158; text-align: center; color: #ffd700; font-weight: bold;">${row.total}</td>`;

                    html += `</tr>`;
                });

                // 캐릭터 구분선
                html += `<tr style="height: 3px; background: #666;"><td colspan="${4 + set.slots.length}" style="padding: 0; border: none;"></td></tr>`;
            });

            html += `</tbody></table>`;
        });

        displayArea.innerHTML = html;
    }

    // ✅ Enter 키로도 검색 가능하도록 이벤트 리스너 추가 (초기화 섹션에 추가)
    document.addEventListener('DOMContentLoaded', function() {
        const searchInput = document.getElementById("equipment-search-input");
        if (searchInput) {
            searchInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') searchEquipment();
            });
        }
    });

    /* ========================================
           [섹션 10] 무기 관리
           ======================================== */

    // ─────────────────────────────────────────
    // 10.1 무기 렌더링
    // ─────────────────────────────────────────
    // ===== 무기 직업 선택 및 버튼 갱신 (종류 열 너비 고정 및 정중앙 정렬) =====
    function selectWeaponJob(jobName, keepOpen = false) {
        const weaponPanel = document.getElementById("weaponPanel");
        const container = document.getElementById("weaponJobButtons");

        if (!keepOpen && activeWeaponJob === jobName) {
            activeWeaponJob = null;
            weaponPanel.innerHTML = "";
            selectWeaponJob(null);
            return;
        }

        activeWeaponJob = jobName;

        // 1. 상단 직업 버튼 생성 및 실시간 합산
        container.innerHTML = "";
        JOB_LIST.forEach(j => {
            let totalCount = 0;
            const jobData = WEAPON_DATA_MAP[j];
            if (jobData) {
                characters.forEach(char => {
                    if (char.weaponCounts) {
                        Object.values(jobData).forEach(weaponList => {
                            weaponList.forEach(weaponName => {
                                WEAPON_PREFIXES.forEach(pref => {
                                    const weaponKey = `${pref.tag} ${weaponName}`;
                                    totalCount += (char.weaponCounts[weaponKey] || 0);
                                });
                            });
                        });
                    }
                });
            }
            const btn = document.createElement("button");
            btn.className = "char-btn" + (j === activeWeaponJob ? " active" : "");
            btn.textContent = `${j} (${totalCount})`;
            btn.onclick = () => selectWeaponJob(j);
            container.appendChild(btn);
        });

        if (!jobName) return;

        const currentData = WEAPON_DATA_MAP[jobName];
        if (!currentData) {
            weaponPanel.innerHTML = `<h3 style="margin-top:20px;">${jobName} 데이터는 준비 중입니다.</h3>`;
            return;
        }

        let html = `<div style="overflow-x: auto; margin-top: 20px; border: 1px solid #2a3158;">`;
        html += `<table id="weaponDetailTable" style="table-layout: fixed; border-collapse: collapse; width: max-content;">`;
        html += `<thead><tr style="background: #181c33;">`;

        // 💡 1. 종류 열의 너비를 120px로 고정 (가장 긴 글자인 '자동권총' 등을 고려)
        html += `<th style="width: 120px; padding: 12px; border: 1px solid #2a3158; white-space: nowrap;">종류</th>`;
        html += `<th style="width: 300px; padding: 12px; border: 1px solid #2a3158; white-space: nowrap;">무기 이름</th>`;

        characters.forEach((char, idx) => {
            const colIdx = idx + 2;
            html += `<th onclick="toggleColumnHighlight(${colIdx})" style="width: 100px; padding: 12px; border: 1px solid #2a3158; white-space: nowrap; text-align: center; cursor: pointer; user-select: none;">${char.job}<br>${char.name}</th>`;
        });
        html += `</tr></thead><tbody>`;

        // ---------------------------------------------------------
        // 💡 종류별 루프 (정중앙 정렬 및 고정 너비 적용)
        // ---------------------------------------------------------
        const categories = Object.keys(currentData);

        categories.forEach((category, cIdx) => {
            const weaponList = currentData[category];
            const rowSpanCount = weaponList.length * WEAPON_PREFIXES.length;

            weaponList.forEach((weaponName, wIdx) => {
                WEAPON_PREFIXES.forEach((pref, pIdx) => {
                    const rowId = `weapon-row-${categories.indexOf(category)}-${wIdx}-${pIdx}`;
                    html += `<tr id="${rowId}" onclick="toggleRowHighlight('${rowId}')">`;

                    // 💡 종류 셀: 가로/세로 정중앙 + 너비 고정 적용
                    if (wIdx === 0 && pIdx === 0) {
                        html += `<td rowspan="${rowSpanCount}" style="background:#181c33; font-weight:bold; width: 120px; border: 1px solid #2a3158; text-align:center; vertical-align: middle; color: #fff; padding: 10px;">${category}</td>`;
                    }

                    const styledName = `<span style="color:${pref.color}; font-weight:bold;">${pref.tag}</span>&nbsp;${weaponName}`;
                    html += `<td style="text-align:left; padding: 8px 15px; white-space: nowrap; border: 1px solid #2a3158; cursor: pointer;">${styledName}</td>`;

                    characters.forEach(char => {
                        const weaponKey = `${pref.tag} ${weaponName}`;
                        const val = (char.weaponCounts && char.weaponCounts[weaponKey]) || 0;
                        html += `<td style="padding: 5px; border: 1px solid #2a3158; text-align:center;">${makeWeaponNumberButton(char.id, weaponKey, val, jobName)}</td>`;
                    });
                    html += `</tr>`;
                });
            });

            // 카테고리 간 구분 공백 (투명)
            if (cIdx < categories.length - 1) {
                html += `<tr style="height: 20px;">`;
                html += `<td colspan="${characters.length + 2}" style="border: none; border-bottom: 1px solid #2a3158; background: transparent;"></td>`;
                html += `</tr>`;
            }
        });

        html += `</tbody></table></div>`;
        weaponPanel.innerHTML = html;

        if (typeof applyStoredHighlights === "function") {
            applyStoredHighlights();
        }
    }

    // 무기 전용 숫자 버튼 생성 함수 (기존 makeNumberButton 복사 및 수정)
    function makeWeaponNumberButton(charId, key, val, jobName) {
        const extraClass = val > 0 ? " positive" : "";
        return `<button class="num-btn${extraClass}"
      oncontextmenu="decrementWeapon('${charId}','${key}', '${jobName}'); return false;"
      onclick="incrementWeapon('${charId}','${key}', '${jobName}')">${val}</button>`;
    }

    // 8-2. 무기 증감
    // 무기 전용 증가 함수
    function incrementWeapon(charId, key, jobName) {
        const char = characters.find(c => c.id === charId);
        if (!char) return;
        if (!char.weaponCounts) char.weaponCounts = {};

        char.weaponCounts[key] = (char.weaponCounts[key] || 0) + 1;
        char.updateTimes[key] = Date.now();

        saveLocalData();

        // 💡 전체 테이블 재렌더링 대신 해당 버튼만 업데이트
        updateWeaponButton(charId, key, char.weaponCounts[key]);
    }

    // 무기 전용 감소 함수
    function decrementWeapon(charId, key, jobName) {
        const char = characters.find(c => c.id === charId);
        if (!char) return;
        if (!char.weaponCounts) char.weaponCounts = {};

        const cur = char.weaponCounts[key] || 0;
        char.weaponCounts[key] = Math.max(0, cur - 1);
        char.updateTimes[key] = Date.now();

        saveLocalData();

        // 💡 전체 테이블 재렌더링 대신 해당 버튼만 업데이트
        updateWeaponButton(charId, key, char.weaponCounts[key]);
    }

    // 💡 무기 버튼만 업데이트하는 헬퍼 함수 (전체 테이블 재렌더링 방지)
    function updateWeaponButton(charId, key, newValue) {
        // 해당 버튼을 찾아서 내용과 스타일만 업데이트
        const table = document.getElementById("weaponDetailTable");
        if (!table) return;

        const buttons = table.querySelectorAll('.num-btn');
        buttons.forEach(btn => {
            // onclick 속성에서 charId와 key가 일치하는 버튼 찾기
            const onclickStr = btn.getAttribute('onclick') || '';
            if (onclickStr.includes(`'${charId}'`) && onclickStr.includes(`'${key}'`)) {
                btn.textContent = newValue;
                // positive 클래스 토글
                if (newValue > 0) {
                    btn.classList.add('positive');
                } else {
                    btn.classList.remove('positive');
                }
            }
        });

        // 상단 직업 버튼의 총 개수도 업데이트
        updateWeaponJobTotals();
    }

    // 💡 직업별 총 개수만 업데이트하는 함수
    function updateWeaponJobTotals() {
        const container = document.getElementById("weaponJobButtons");
        if (!container) return;

        JOB_LIST.forEach(j => {
            let totalCount = 0;
            const jobData = WEAPON_DATA_MAP[j];
            if (jobData) {
                characters.forEach(char => {
                    if (char.weaponCounts) {
                        Object.values(jobData).forEach(weaponList => {
                            weaponList.forEach(weaponName => {
                                WEAPON_PREFIXES.forEach(pref => {
                                    const weaponKey = `${pref.tag} ${weaponName}`;
                                    totalCount += (char.weaponCounts[weaponKey] || 0);
                                });
                            });
                        });
                    }
                });
            }

            // 해당 직업 버튼 찾아서 텍스트만 업데이트
            const buttons = container.querySelectorAll('.char-btn');
            buttons.forEach(btn => {
                if (btn.textContent.startsWith(j)) {
                    btn.textContent = `${j} (${totalCount})`;
                }
            });
        });
    }

    // 8-3. 무기 테이블 강조
    function toggleRowHighlight(rowId) {
        const table = document.getElementById("weaponDetailTable");
        if (!table) return;

        const rows = table.querySelectorAll('tbody tr');

        // 이미 선택된 행을 다시 누르면 해제
        if (highlightedRowId === rowId) {
            highlightedRowId = null;
        } else {
            highlightedRowId = rowId;
        }

        // 모든 행의 강조 해제
        rows.forEach(row => {
            row.style.backgroundColor = "";
        });

        // 선택된 행만 강조
        if (highlightedRowId) {
            const selectedRow = document.getElementById(highlightedRowId);
            if (selectedRow) {
                selectedRow.style.backgroundColor = "rgba(255, 255, 200, 0.15)";
            }
        }
    }

    function toggleColumnHighlight(colIdx) {
        // 💡 이미 선택된 열을 다시 누르면 해제, 아니면 해당 열 번호 저장
        if (highlightedColumnIndex === colIdx) {
            highlightedColumnIndex = null;
        } else {
            highlightedColumnIndex = colIdx;
        }
        applyStoredHighlights();
    }

    function applyStoredHighlights() {
        const table = document.getElementById("weaponDetailTable");
        if (!table) return;

        const rows = table.rows;
        for (let i = 0; i < rows.length; i++) {
            const cells = rows[i].cells;

            // 종류/무기이름 셀을 제외한 실제 캐릭터 데이터 셀들의 시작 위치 계산
            const charStartIdx = cells.length - characters.length;

            characters.forEach((_, charIdx) => {
                const currentCellIdx = charStartIdx + charIdx;
                const absoluteColIdx = charIdx + 2; // 캐릭터의 고유 순번(2번부터 시작)

                if (cells[currentCellIdx]) {
                    // 💡 현재 순번이 저장된 단일 선택 인덱스와 일치할 때만 강조
                    if (highlightedColumnIndex === absoluteColIdx) {
                        cells[currentCellIdx].style.backgroundColor = "rgba(255, 255, 200, 0.15)";
                    } else {
                        // 강조되지 않은 셀은 원래 색상으로 복구
                        cells[currentCellIdx].style.backgroundColor = i === 0 ? "#181c33" : "";
                    }
                }
            });
        }
    }

    /* ========================================
       [섹션 11] 최근 업데이트 내역
       ======================================== */
    function showRecentUpdates() {
        allUpdatesData = [];

        characters.forEach(char => {
            Object.entries(char.updateTimes).forEach(([fullKey, timestamp]) => {
                if (!timestamp || timestamp <= 0) return;

                if (char.armorCounts && char.armorCounts[fullKey] !== undefined) {
                    const parts = fullKey.split(' ');
                    const slot = parts.pop();
                    const itemName = parts.join(' ');

                    let category = "방어구";
                    const baseName = itemName.split(':').pop().trim();
                    const setType = getSetType(baseName);
                    if (setType === "ACCESSORY") category = "악세";
                    else if (setType === "SPECIAL") category = "특장";

                    allUpdatesData.push({
                        name: char.name, job: char.job, itemName: itemName,
                        category: category, slot: slot, count: char.armorCounts[fullKey], timestamp: timestamp
                    });
                } else if (char.weaponCounts && char.weaponCounts[fullKey] !== undefined) {
                    let weaponSubCategory = "-";
                    outerLoop:
                        for (const jobData of Object.values(WEAPON_DATA_MAP)) {
                            for (const [catName, list] of Object.entries(jobData)) {
                                if (list.some(name => fullKey.includes(name))) {
                                    weaponSubCategory = catName;
                                    break outerLoop;
                                }
                            }
                        }
                    allUpdatesData.push({
                        name: char.name, job: char.job, itemName: fullKey,
                        category: "무기", slot: weaponSubCategory, count: char.weaponCounts[fullKey], timestamp: timestamp
                    });
                }
            });
        });

        allUpdatesData.sort((a, b) => b.timestamp - a.timestamp);

        const modalContent = document.getElementById("updateModalContent");
        if (allUpdatesData.length === 0) {
            modalContent.innerHTML = "<p>최근 업데이트된 내역이 없습니다.</p>";
            document.getElementById("updatePagination").innerHTML = "";
            document.getElementById("updateModal").style.display = 'flex';
            return;
        }

        currentUpdatePage = 1;
        renderUpdatePage(1);
        document.getElementById("updateModal").style.display = 'flex';
    }

    function renderUpdatePage(pageNum) {
        const modalContent = document.getElementById("updateModalContent");
        const paginationContainer = document.getElementById("updatePagination");

        const startIdx = (pageNum - 1) * ITEMS_PER_PAGE;
        const endIdx = startIdx + ITEMS_PER_PAGE;
        const pageItems = allUpdatesData.slice(startIdx, endIdx);

        const table = document.createElement("table");
        table.style.width = '100%';
        table.innerHTML = `<thead><tr>
    <th style="width:20%;">직업 / 이름</th>
    <th style="width:15%;">종류 (부위)</th>
    <th style="width:35%;">아이템</th>
    <th style="width:10%;">보유 개수</th>
    <th style="width:20%;">업데이트 시간</th>
</tr></thead><tbody></tbody>`;

        const tbody = table.querySelector("tbody");

        pageItems.forEach(item => {
            const date = new Date(item.timestamp);
            const formatTime = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;

            let styledItemName = item.itemName;
            const tagMatch = styledItemName.match(/^(\[.*?\])\s*(.*)/);

            if (tagMatch) {
                const tag = tagMatch[1];
                const restName = tagMatch[2];
                let tagColor = '#ffd700';
                if (tag.includes('선봉') || tag.includes('분쇄')) tagColor = '#ff4d4f';
                else if (tag.includes('의지') || tag.includes('광채')) tagColor = '#3399cc';
                else if (tag.includes('이상')) tagColor = '#25c2a0';
                else if (tag.includes('강타')) tagColor = '#ffd700';

                let baseNamePart = restName;
                if (restName.includes(':')) {
                    const pMatch = restName.match(/(.+?):\s*(.+)/);
                    if (pMatch) baseNamePart = `<span style="color:#e6b800; font-weight:bold;">${pMatch[1]}</span>: ${pMatch[2]}`;
                }
                styledItemName = `<span style="color:${tagColor}; font-weight:bold;">${tag}</span> ${baseNamePart}`;
            } else if (styledItemName.includes(':')) {
                const pMatch = styledItemName.match(/(.+?):\s*(.+)/);
                if (pMatch) styledItemName = `<span style="color:#e6b800; font-weight:bold;">${pMatch[1]}</span>: ${pMatch[2]}`;
            }

            const tr = document.createElement("tr");
            tr.innerHTML = `
        <td style="white-space:nowrap;">${item.job} / ${item.name}</td>
        <td>[${item.category}] ${item.slot}</td>
        <td style="text-align:left;">${styledItemName}</td>
        <td style="font-weight:bold; color:${item.count > 0 ? '#ffcc00' : '#888'};">${item.count}</td>
        <td style="font-size:0.9em;">${formatTime}</td>
    `;
            tbody.appendChild(tr);
        });

        modalContent.innerHTML = "";
        modalContent.appendChild(table);

        renderPaginationButtons(pageNum);
    }

    function renderPaginationButtons(currentPage) {
        const paginationContainer = document.getElementById("updatePagination");
        paginationContainer.innerHTML = "";

        const totalPages = Math.ceil(allUpdatesData.length / ITEMS_PER_PAGE);

        // 데이터가 없으면 버튼 생성 안 함
        if (totalPages === 0) return;

        // 처음으로 버튼
        const firstBtn = document.createElement("button");
        firstBtn.textContent = "⏮ 처음으로";
        firstBtn.disabled = currentPage === 1;
        firstBtn.onclick = () => { currentUpdatePage = 1; renderUpdatePage(1); };
        paginationContainer.appendChild(firstBtn);

        // 이전 페이지 버튼
        const prevBtn = document.createElement("button");
        prevBtn.textContent = "◀ 이전";
        prevBtn.disabled = currentPage === 1;
        prevBtn.onclick = () => {
            if (currentPage > 1) { currentUpdatePage = currentPage - 1; renderUpdatePage(currentUpdatePage); }
        };
        paginationContainer.appendChild(prevBtn);

        // 페이지 범위 계산 (현재 페이지 기준으로 5개씩)
        const pageGroupStart = Math.floor((currentPage - 1) / 5) * 5 + 1;
        const pageGroupEnd = Math.min(pageGroupStart + 4, totalPages);

        // 페이지 번호 버튼 (5개씩 표시)
        for (let i = pageGroupStart; i <= pageGroupEnd; i++) {
            const pageBtn = document.createElement("button");
            pageBtn.textContent = i;
            pageBtn.className = currentPage === i ? "active" : "";
            pageBtn.onclick = () => { currentUpdatePage = i; renderUpdatePage(i); };
            paginationContainer.appendChild(pageBtn);
        }

        // 다음 페이지 버튼
        const nextBtn = document.createElement("button");
        nextBtn.textContent = "다음 ▶";
        nextBtn.disabled = currentPage === totalPages;
        nextBtn.onclick = () => {
            if (currentPage < totalPages) { currentUpdatePage = currentPage + 1; renderUpdatePage(currentUpdatePage); }
        };
        paginationContainer.appendChild(nextBtn);

        // 끝으로 버튼
        const lastBtn = document.createElement("button");
        lastBtn.textContent = "끝으로 ⏭";
        lastBtn.disabled = currentPage === totalPages;
        lastBtn.onclick = () => { currentUpdatePage = totalPages; renderUpdatePage(totalPages); };
        paginationContainer.appendChild(lastBtn);

        // 페이지 검색 입력창 추가
        const searchDiv = document.createElement("div");
        searchDiv.style.display = "flex";
        searchDiv.style.gap = "8px";
        searchDiv.style.alignItems = "center";
        searchDiv.style.marginLeft = "15px";

        const searchLabel = document.createElement("span");
        searchLabel.textContent = "페이지 검색:";
        searchLabel.style.color = "#e6e9ff";
        searchLabel.style.fontWeight = "bold";
        searchDiv.appendChild(searchLabel);

        const searchInput = document.createElement("input");
        searchInput.type = "number";
        searchInput.min = "1";
        searchInput.max = totalPages;
        searchInput.placeholder = `1-${totalPages}`;
        searchInput.style.cssText = "width:80px; padding:8px; border:1px solid #2a3158; background:#181c33; color:#e6e9ff; border-radius:6px; text-align:center;";

        const searchBtn = document.createElement("button");
        searchBtn.textContent = "🔍 이동";
        searchBtn.style.cssText = "padding:8px 15px; border:1px solid #2a3158; background:#25c2a0; color:#fff; border-radius:6px; cursor:pointer; font-weight:bold;";
        searchBtn.onclick = () => {
            const pageNum = parseInt(searchInput.value);
            if (isNaN(pageNum) || pageNum < 1 || pageNum > totalPages) {
                alert(`1 ~ ${totalPages} 사이의 페이지를 입력하세요.`);
                return;
            }
            currentUpdatePage = pageNum;
            renderUpdatePage(pageNum);
        };

        // Enter 키로도 검색 가능
        searchInput.onkeypress = (e) => {
            if (e.key === "Enter") searchBtn.click();
        };

        searchDiv.appendChild(searchInput);
        searchDiv.appendChild(searchBtn);
        paginationContainer.appendChild(searchDiv);
    }

    // 💡 새로 추가: 업데이트 모달 닫기 함수
    function closeUpdateModal() {
        document.getElementById("updateModal").style.display = 'none';
    }

    /* ========================================
       [섹션 12] 제작 시스템
       ======================================== */
    function renderCraftTable() {
        const area = document.getElementById("craft-table-area");

        // ✅ 현재 포커스된 input의 위치 저장
        const focusedElement = document.activeElement;
        let focusedCharIndex = -1;
        let focusedMatIndex = -1;

        if (focusedElement && focusedElement.className === "craft-input") {
            // 어느 캐릭터, 어느 재료인지 찾기
            const allInputs = Array.from(document.querySelectorAll(".craft-input"));
            const focusedIndex = allInputs.indexOf(focusedElement);

            if (focusedIndex !== -1) {
                const materialsCount = 8; // 재료 개수
                focusedCharIndex = Math.floor(focusedIndex / materialsCount);
                focusedMatIndex = focusedIndex % materialsCount;
            }
        }

        area.innerHTML = "";

        const materials = [
            { name: "망가진 기계 캡슐", img: "망가진기계캡슐.png" },
            { name: "스펙쿨룸 파편", img: "스펙쿨룸파편.png" },
            { name: "망가진 강철 톱니바퀴", img: "망가진강철톱니바퀴.png" },
            { name: "강철 화로의 파편", img: "강철화로의파편.png" },
            { name: "빛의 저장소", img: "빝의저장소.png" },
            { name: "마누스 메모리얼", img: "마누스메모리얼.png" },
            { name: "데이터 칩 상자", img: "데이터칩.png" },
            { name: "강화된 데이터 칩 상자", img: "강화된데이터칩.png" }
        ];

        const table = document.createElement("table");

        // ✅ 헤더 1행: 재료명 + 합계
        const headerRow1 = document.createElement("tr");
        const emptyTh = document.createElement("th");
        emptyTh.textContent = "캐릭터";
        headerRow1.appendChild(emptyTh);

        materials.forEach(mat => {
            const th = document.createElement("th");
            th.textContent = mat.name;
            headerRow1.appendChild(th);
        });

        // ✅ 합계 열 헤더
        const totalTh = document.createElement("th");
        totalTh.textContent = "합계";
        totalTh.style.background = "#ffd700";
        totalTh.style.color = "#000";
        headerRow1.appendChild(totalTh);

        table.appendChild(headerRow1);

        // ✅ 헤더 2행: 재료 이미지 + 빈 칸
        const headerRow2 = document.createElement("tr");
        const emptyTh2 = document.createElement("th");
        headerRow2.appendChild(emptyTh2);

        materials.forEach(mat => {
            const th = document.createElement("th");
            th.innerHTML = `<img src="${mat.img}" style="width:32px;">`;
            headerRow2.appendChild(th);
        });

        // ✅ 합계 열 빈 칸
        const emptyTotalTh = document.createElement("th");
        emptyTotalTh.style.background = "#ffd700";
        headerRow2.appendChild(emptyTotalTh);

        table.appendChild(headerRow2);

        // ✅ 재료별 합계를 저장할 배열
        const materialTotals = materials.map(() => 0);

        // ✅ 데이터 행: 각 캐릭터
        characters.forEach((char, charIdx) => {
            if (!char.craftMaterials) {
                char.craftMaterials = {};
            }

            const tr = document.createElement("tr");

            // 캐릭터 이름
            const nameTd = document.createElement("td");
            nameTd.innerHTML = `${char.job}<br>(${char.name})`;
            nameTd.style.fontWeight = "bold";
            tr.appendChild(nameTd);

            let charTotal = 0; // 캐릭터별 합계

            // 각 재료의 입력 필드
            materials.forEach((mat, matIdx) => {
                const td = document.createElement("td");
                const input = document.createElement("input");
                input.type = "number";
                input.className = "craft-input";
                input.style.width = "60px";
                input.min = "0";
                input.placeholder = "0";

                const savedValue = char.craftMaterials[mat.name];
                if (savedValue && savedValue > 0) {
                    input.value = savedValue;
                    charTotal += savedValue;
                    materialTotals[matIdx] += savedValue;
                }

                input.addEventListener('input', function() {
                    const value = parseInt(this.value);

                    if (isNaN(value) || value <= 0) {
                        delete char.craftMaterials[mat.name];
                    } else {
                        char.craftMaterials[mat.name] = value;
                    }

                    saveLocalData();
                    renderCraftTable(); // ✅ 합계 갱신을 위해 재렌더링
                });

                // ✅ 포커스 복원
                if (charIdx === focusedCharIndex && matIdx === focusedMatIndex) {
                    setTimeout(() => {
                        input.focus();
                        // 커서를 끝으로 이동
                        const len = input.value.length;
                        input.setSelectionRange(len, len);
                    }, 0);
                }

                td.appendChild(input);
                tr.appendChild(td);
            });

            // ✅ 캐릭터별 합계 표시
            const totalTd = document.createElement("td");
            totalTd.textContent = charTotal > 0 ? charTotal : "";
            totalTd.style.textAlign = "center";
            totalTd.style.fontWeight = "bold";
            totalTd.style.background = "#ffd700";
            totalTd.style.color = "#000";
            tr.appendChild(totalTd);

            table.appendChild(tr);
        });

        // ✅ 합계 행 추가
        const totalRow = document.createElement("tr");
        totalRow.style.background = "#ffd700";

        const totalLabelTd = document.createElement("td");
        totalLabelTd.textContent = "합계";
        totalLabelTd.style.fontWeight = "bold";
        totalLabelTd.style.color = "#000";
        totalLabelTd.style.textAlign = "center";
        totalRow.appendChild(totalLabelTd);

        let grandTotal = 0;

        materialTotals.forEach(total => {
            const td = document.createElement("td");
            td.textContent = total > 0 ? total : "";
            td.style.textAlign = "center";
            td.style.fontWeight = "bold";
            td.style.color = "#000";
            grandTotal += total;
            totalRow.appendChild(td);
        });

        // ✅ 전체 합계 (오른쪽 아래)
        const grandTotalTd = document.createElement("td");
        grandTotalTd.textContent = grandTotal > 0 ? grandTotal : "";
        grandTotalTd.style.textAlign = "center";
        grandTotalTd.style.fontWeight = "bold";
        grandTotalTd.style.color = "#000";
        grandTotalTd.style.fontSize = "1.1em";
        totalRow.appendChild(grandTotalTd);

        table.appendChild(totalRow);

        area.appendChild(table);
        setCraftLock(craftLocked);
    }

    function setCraftLock(lock) {
        craftLocked = lock;

        // 버튼 상태 변경
        document.getElementById("craft-lock-btn")
            .classList.toggle("active", lock);
        document.getElementById("craft-unlock-btn")
            .classList.toggle("active", !lock);

        // 입력칸 활성/비활성
        document.querySelectorAll("#section-craft-view input")
            .forEach(input => {
                input.disabled = lock;
            });
    }

    /* ========================================
       [섹션 13] 탭 전환
       ======================================== */
    // 3-1. 화면 전환 함수 수정
    function switchTo(view) {
        const sections = {
            'char': document.getElementById("section-character-view"),
            'weapon': document.getElementById("section-weapon-view"),
            'equipment': document.getElementById("section-equipment-view"),
            'craft': document.getElementById("section-craft-view") // ✅ 추가
        };
        const buttons = {
            'char': document.getElementById("tab-char"),
            'weapon': document.getElementById("tab-weapon"),
            'equipment': document.getElementById("tab-equipment"),
            'craft': document.getElementById("tab-craft") // ✅ 추가
        };

        // 모든 섹션 숨기고 버튼 스타일 초기화
        Object.keys(sections).forEach(k => {
            if (sections[k]) sections[k].style.display = "none";
            if (buttons[k]) {
                buttons[k].style.background = "#2a3158";
                buttons[k].style.border = "2px solid transparent";
            }
        });

        // 선택된 섹션 보이기 및 버튼 강조
        if (sections[view]) sections[view].style.display = "block";
        if (buttons[view]) {
            buttons[view].style.background = "#4a33cc";
            buttons[view].style.border = "2px solid #fff";
        }

        // 탭별 초기 데이터 로드
        if (view === 'char') renderCharacterList();
        if (view === 'weapon') selectWeaponJob('귀검사', true);
        if (view === 'equipment') {
            renderEquipmentTab('ALL');

            // 장비 관리 툴바의 첫 번째 버튼을 찾아서 active 클래스 부여
            const equipmentToolbar = document.querySelector("#section-equipment-view .toolbar");
            const firstBtn = equipmentToolbar.querySelector(".char-btn");

            // 모든 장비 버튼 초기화 후 첫 번째 버튼만 켬
            equipmentToolbar.querySelectorAll(".char-btn").forEach(b => b.classList.remove("active"));
            if (firstBtn) firstBtn.classList.add("active");
        }
        if (view === 'craft') renderCraftTable();

        window.scrollTo(0, 0);
    }

    /* ========================================
       [섹션 14] JSON 백업/복원
       ======================================== */
    function exportJSON() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');

        // 변경된 파일명 형식: dnfm_eq_YYYY-MM-DD_HH-MM.json
        const fileName = `dnfm_eq_${year}-${month}-${day}_${hours}-${minutes}.json`;

        const dataStr = JSON.stringify(characters, null, 2);
        const blob = new Blob([dataStr], {type: "application/json"});
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    async function saveJsonWithLocation() {
        const dataStr = localStorage.getItem('dnfm_eq');
        if (!dataStr) {
            alert("저장할 데이터가 없습니다.");
            return;
        }

        // 파일 기본 이름 설정 (오늘 날짜 포함)
        const defaultName = "dnfm_eq_JSON_backup_" + new Date().toISOString().slice(0, 10) + ".json";

        // 1. 최신 브라우저용 (File System Access API) - 직접 폴더/이름 지정 가능
        if ('showSaveFilePicker' in window) {
            try {
                const handle = await window.showSaveFilePicker({
                    suggestedName: defaultName,
                    types: [{
                        description: 'JSON Files',
                        accept: { 'application/json': ['.json'] },
                    }],
                });

                const writable = await handle.createWritable();
                await writable.write(dataStr);
                await writable.close();

                alert("지정된 위치에 저장되었습니다.");
            } catch (err) {
                // 사용자가 취소를 누른 경우 외의 에러 처리
                if (err.name !== 'AbortError') {
                    console.error(err);
                    alert("파일 저장 중 오류가 발생했습니다.");
                }
            }
        }
        // 2. 구형 브라우저/모바일용 (대체 수단)
        else {
            alert("현재 브라우저가 저장 위치 지정을 직접 지원하지 않아 기본 다운로드 방식으로 진행합니다.");
            const blob = new Blob([dataStr], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = defaultName;
            link.click();
            URL.revokeObjectURL(url);
        }
    }

    function importJSON(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
            try {
                const imported = JSON.parse(e.target.result);

                if (!Array.isArray(imported)) {
                    throw new Error("데이터가 배열 형식이 아닙니다.");
                }

                // 1. 전역 데이터 교체 및 필수 필드 보정
                characters = imported.map(char => {
                    if (!char.name || !char.job) throw new Error("캐릭터 이름 또는 직업 정보가 누락된 항목이 있습니다.");
                    return {
                        id: char.id || "c" + Date.now() + Math.random().toString(36).substr(2, 5),
                        name: char.name,
                        job: char.job,
                        armorCounts: char.armorCounts || {},
                        weaponCounts: char.weaponCounts || {},
                        updateTimes: char.updateTimes || {},
                        craftMaterials: char.craftMaterials || {}
                    };
                });

                // 2. 상태 초기화 (UI 꼬임 방지)
                activeCharacterId = null;
                currentSetName = null;
                currentChar = null;

                // 3. 로컬 저장
                saveLocalData();

                // 4. ✅ 각 섹션 DOM 요소 미리 가져오기
                const charView = document.getElementById("section-character-view");
                const weaponView = document.getElementById("section-weapon-view");
                const equipmentView = document.getElementById("section-equipment-view");
                const craftView = document.getElementById("section-craft-view");

                // 5. 캐릭터 탭 갱신 (항상)
                renderCharacterList();
                document.getElementById("setList").innerHTML = "";
                document.getElementById("panel").innerHTML = "";

                // 6. 무기 탭이 열려있으면 갱신
                if (weaponView.style.display !== "none") {
                    selectWeaponJob(activeWeaponJob || '귀검사', true);
                }

                // 7. ✅ 장비 관리 탭이 열려있으면 갱신
                if (equipmentView.style.display !== "none") {
                    // ✅ 캐릭터별 장비 보유 현황이 열려있으면 갱신
                    if (isCharacterEquipmentViewOpen && selectedCharacterForEquipment) {
                        const char = characters.find(c => c.id === selectedCharacterForEquipment);
                        if (char) {
                            renderCharacterButtons();
                            renderCharacterEquipmentDetail(char);
                        }
                    } else {
                        // 일반 장비 관리 화면이면 갱신
                        renderEquipmentTab('ALL');
                    }
                }

                // 8. 제작 탭이 열려있으면 갱신
                if (craftView.style.display !== "none") {
                    renderCraftTable();
                }

                alert(`데이터 복구 완료! 총 ${characters.length}명의 데이터가 적용되었습니다.`);
                event.target.value = '';

            } catch (err) {
                console.error(err);
                alert("파일 읽기 중 오류 발생: " + err.message);
            }
        };
        reader.readAsText(file);
    }

    /* ========================================
       [섹션 15] 초기화 & 이벤트 리스너
       ======================================== */
    calculateGlobalWidths();
    loadLocalData();
    renderCharacterList();
    selectWeaponJob('귀검사');

    // 모바일 환경 터치 대응 통합
    window.ontouchstart = function (event) {
        const prefixModal = document.getElementById("prefixFullModal");
        const updateModal = document.getElementById("updateModal");
        const actionModal = document.getElementById("actionModal");
        const confirmModal = document.getElementById("confirmModal");

        if (event.target === prefixModal) prefixModal.style.display = 'none';
        if (event.target === updateModal) updateModal.style.display = 'none';
        if (event.target === actionModal) actionModal.style.display = 'none';
        if (event.target === confirmModal) {
            if (typeof closeConfirmModal === "function") closeConfirmModal();
            else confirmModal.style.display = 'none';
        }
    };

    // Enter 키 검색 지원
    const searchInput = document.getElementById("equipment-search-input");
    if (searchInput) {
        searchInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchEquipment();
            }
        });
    }

    // // 모바일 환경을 위한 터치 이벤트 대응
    // window.ontouchstart = function (event) {
    //     const modal = document.getElementById("updateModal");
    //     if (event.target === modal) {
    //         modal.style.display = 'none';
    //     }
    // };
    //
    //
    // // 모바일 터치 대응 (터치 시작 시 닫기)
    // window.ontouchstart = function (event) {
    //     const modal = document.getElementById("prefixFullModal");
    //     if (event.target === modal) {
    //         modal.style.display = "none";
    //     }
    // };


    // // 모든 팝업창 외부 클릭 시 닫기 처리 (통합 버전)
    // window.onclick = function (event) {
    //     const updateModal = document.getElementById("updateModal");
    //     const prefixModal = document.getElementById("prefixFullModal");
    //     const actionModal = document.getElementById("actionModal");
    //     const confirmModal = document.getElementById("confirmModal");
    //
    //     // 1. 최근 업데이트 내역 모달
    //     if (event.target === updateModal) {
    //         updateModal.style.display = 'none';
    //     }
    //     // 2. 전체 장비 현황 모달
    //     if (event.target === prefixModal) {
    //         prefixModal.style.display = 'none';
    //     }
    //     // 3. 캐릭터 액션(수정/삭제 등) 모달
    //     if (event.target === actionModal) {
    //         actionModal.style.display = 'none';
    //     }
    //     // 4. 확인(Confirm) 모달
    //     if (event.target === confirmModal) {
    //         if (typeof closeConfirmModal === "function") closeConfirmModal();
    //         else confirmModal.style.display = 'none';
    //     }
    // };


    /* ========================================
   [테스트용 export]
   Node.js(logic.js 브릿지)에서 이 HTML을 파싱할 때만 사용됨.
   브라우저에서는 typeof exports === 'undefined' 이므로 무시됨.
   ======================================== */
    if (typeof exports !== 'undefined') {
        Object.assign(exports, {
            // 상수
            ARMOR_SETS, ACCESSORY_SETS, SPECIAL_SETS, ALL_SETS,
            ARMOR_PREFIX, ACCESSORY_PREFIX, SPECIAL_PREFIX, ALL_PREFIX,
            ARMOR_EXCEED_ONLY, ACCESSORY_EXCEED_ONLY,
            LEGACY_PREFIX_SETS, EXCEED_TAGS, EXCEED_SLOTS,
            // 순수 로직 함수
            makePrefixKey, isExceedName, getGroupKey, getSetType,
            calcTotalDistinctParts,
            // 정렬 (DOM 의존 부분 제거한 순수 로직만)
            _sortByName: (chars) => [...chars].sort((a, b) => a.name.localeCompare(b.name, 'ko-KR')),
            _sortByJob:  (chars) => [...chars].sort((a, b) => {
                const j = a.job.localeCompare(b.job, 'ko-KR');
                return j !== 0 ? j : a.name.localeCompare(b.name, 'ko-KR');
            }),
            // 카운트 증감 (DOM 의존 부분 제거한 순수 로직만)
            _incrementCount: (char, key) => { char.armorCounts[key] = (char.armorCounts[key] || 0) + 1; },
            _decrementCount: (char, key) => { char.armorCounts[key] = Math.max(0, (char.armorCounts[key] || 0) - 1); },
            // 세트 완성도
            _getSetType3or5: (count, setName) => {
                const slots = ALL_SETS[setName] || [];
                const total = slots.length;
                if (total === 0) return null;
                const ratio = count / total;
                if (ratio >= 1.0) return 5;
                if (ratio >= 0.6) return 3;
                return null;
            },
        });
    }

</script>

</div>

<div id="actionModal" class="modal-overlay" style="display:none;">
    <div class="modal-content"></div>
</div>

<div id="confirmModal" class="modal-overlay" style="display:none;">
    <div class="modal-content" style="min-width: 300px; text-align: center;">
        <h3 id="confirmTitle" style="color: #fff; margin-bottom: 15px;"></h3>
        <p id="confirmMessage" style="color: #ccc; margin-bottom: 25px;"></p>

        <div class="modal-options" style="display: flex; gap: 10px; justify-content: center;">
            <button id="confirmYes" class="modal-btn" style="background: #e74c3c; flex: 1; color: #fff;">확인</button>
            <button class="modal-btn" style="background: #444; flex: 1; color: #fff;" onclick="closeConfirmModal()">취소
            </button>
        </div>
    </div>
</div>
<!--gap 값: 화살표 사이 간격-->
<div class="scroll-buttons" style="position: fixed; bottom: 20px; right: 20px; display: flex; flex-direction: column; gap: 5px; z-index: 1000;">
    <button onclick="window.scrollTo({top: 0, behavior: 'smooth'})"
            style="width: 40px; height: 40px; border-radius: 50%; background: #4a33cc; color: white; border: 2px solid #fff; cursor: pointer; font-size: 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.3);">
        ▲
    </button>
    <button onclick="window.scrollTo({top: document.body.scrollHeight, behavior: 'smooth'})"
            style="width: 40px; height: 40px; border-radius: 50%; background: #4a33cc; color: white; border: 2px solid #fff; cursor: pointer; font-size: 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.3);">
        ▼
    </button>
</div>
</body>
</html>